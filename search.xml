<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue3.0 Basics</title>
      <link href="/posts/Vue3-0-Basics.html"/>
      <url>/posts/Vue3-0-Basics.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Vue3-简介"><a href="#1-Vue3-简介" class="headerlink" title="1. Vue3 简介"></a>1. Vue3 简介</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Developer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basics of mechanics</title>
      <link href="/posts/Basics-of-mechanics.html"/>
      <url>/posts/Basics-of-mechanics.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数学补充知识"><a href="#1-数学补充知识" class="headerlink" title="1. 数学补充知识"></a>1. 数学补充知识</h2><h3 id="1-1-矢量的标积"><a href="#1-1-矢量的标积" class="headerlink" title="1.1 矢量的标积"></a>1.1 矢量的标积</h3><p>两个矢量 \(\mathbf A,\mathbf B\) 的标积，书写和定义为</p><p>$$<br>\mathbf A \cdot \mathbf B &#x3D; AB\cos\phi<br>$$</p><p>其中 \(\phi\) 是 \(\mathbf A\) 与 \(\mathbf B\) 间的夹角。</p><p>标积在力学中有着重要的应用，计算力的做功便是一例。质点在运动中的一段无限小的位移矢量若记为 \(\Delta\mathbf l\)，其间受力 \(\mathbf F\)，力 \(\mathbf F\) 在此过程中对质做的功 \(\Delta \mathbf W\) 定义为</p><p>$$<br>\Delta W &#x3D; \mathbf F \cdot \Delta \mathbf l<br>$$</p><h3 id="1-2-矢量的矢积"><a href="#1-2-矢量的矢积" class="headerlink" title="1.2 矢量的矢积"></a>1.2 矢量的矢积</h3><p>三维空间两个矢量 \(\mathbf A, \mathbf B\) 的矢积，书写和定义为</p><p>$$<br>\mathbf A \times \mathbf B &#x3D; \mathbf C<br>$$</p><p>其中 \(C\) 的大小为 \(AB \sin \phi\) ，\(C\) 的方向或由右手系确定。在几何上 \(C\) 的值等于矢量 \(\mathbf A, \mathbf B\) 形成的平行四边形的面积。</p><p>矢积有些基本性质，如</p><p>$$<br>(\alpha \mathbf A)\times \mathbf B &#x3D; \alpha(\mathbf A \times \mathbf B)<br>$$</p><p>$$<br>\mathbf A \times \mathbf B &#x3D; - \mathbf B \times \mathbf A<br>$$</p><p>$$<br>(\mathbf A_1 + \mathbf A_2)  \times \mathbf B &#x3D; \mathbf A_1 \times \mathbf B + \mathbf A_2 \times \mathbf B<br>$$</p><p>矢积只能在 3 维空间中进行，矢积点行列式表达式</p><p>$$<br>\mathbf A \times \mathbf B &#x3D; \left | \begin{matrix}<br>\mathbf i &amp; A_x   &amp; B_x   \\<br>\mathbf j &amp; A_y &amp; B_y    \\<br>\mathbf k &amp; A_z &amp; B_z   \\<br>\end{matrix} \right |<br>$$</p><p>在电学中，电量为 \(q\) 、速度为 \(v\) 的粒子在磁场中所受洛伦兹力可表述为</p><p>$$<br>\mathbf F &#x3D; q \mathbf v \times \mathbf B<br>$$</p><p>其中 \(\mathbf B\) 是粒子所在处磁场的磁感应强度。</p><h3 id="1-3-矢量的三重积"><a href="#1-3-矢量的三重积" class="headerlink" title="1.3 矢量的三重积"></a>1.3 矢量的三重积</h3><p>3 维空间中 3 个矢量间形如<br>$$<br>\mathbf A \cdot (\mathbf B \times \mathbf C)<br>$$</p><p>的运算，称为矢量的三重标积，所得是个标量。从空间角度上，3 个不共面的矢量三重标积的绝对值，等于 3 个矢量构成的平行六面体体积。考虑到标积等于矢量分量乘积之和，结合矢积的行列式表述，可导得三重标积点行列式表述：</p><p>$$<br>\mathbf A \cdot (\mathbf B \times \mathbf C) &#x3D;<br>\begin{vmatrix}<br>A_x &amp; B_x &amp; C_x \\<br>A_y &amp; B_y &amp; C_y \\<br>A_z &amp; B_z &amp; C_z<br>\end{vmatrix}<br>$$</p><p>利用行列式的展开，进而可得三重标积点循环可交换性，既有<br>$$<br>\mathbf A \cdot (\mathbf B \times \mathbf C) &#x3D; \mathbf B \cdot (\mathbf C \times \mathbf A) &#x3D; \mathbf C \cdot (\mathbf A \times \mathbf B)<br>$$<br>3 维空间中 3 个矢量间形如<br>$$<br>\mathbf A \times (\mathbf B \times \mathbf C)<br>$$<br>的运算，称为矢量的三重矢积，所得是个矢量。为了简化推导过程，在空间上沿着 \(\mathbf B\) 方向设置 x 轴，于是便有<br>$$<br>\begin{aligned}<br>\mathbf B &amp;&#x3D; B_x \mathbf i,  \\<br>\mathbf C &amp;&#x3D; C_x \mathbf i + C_y \mathbf j \\<br>\mathbf A &amp;&#x3D; A_x \mathbf i + A_y \mathbf j  + A_z \mathbf k<br>\end{aligned}<br>$$</p><p>\(\mathbf A, \mathbf B, \mathbf C\) 的三重矢积展开如下<br>$$<br>\begin{aligned}<br>&amp;\mathbf A \times (\mathbf B \times \mathbf C) \\<br>&#x3D;&amp;(A_x\mathbf i  + A_y\mathbf j + A_z  \mathbf k) \times [(B_x\mathbf i) \times (C_x \mathbf i + C_y \mathbf j)] \\<br>&#x3D;&amp; (A_x\mathbf i  + A_y\mathbf j + A_z  \mathbf k) \times(B_xC_y\mathbf k) \\<br>&#x3D;&amp; -A_xB_xC_y \mathbf j + A_yB_xC_y\mathbf i \\<br>&#x3D;&amp; -A_xB_xC_y \mathbf j + A_yB_xC_y\mathbf i  + A_xB_xC_x\mathbf i - A_xB_xC_x\mathbf j \\<br>&#x3D;&amp;(A_xC_x + A_yC_y)B_x\mathbf i -A_xB_x(C_x\mathbf i + C_y\mathbf j)<br>\end{aligned}<br>$$<br>既得<br>$$<br>\mathbf A \times (\mathbf B \times \mathbf C)&#x3D;(\mathbf A \cdot \mathbf C) \mathbf B - (\mathbf A \cdot \mathbf B) C<br>$$</p><h3 id="1-4-微分"><a href="#1-4-微分" class="headerlink" title="1.4 微分"></a>1.4 微分</h3><p>\(\text{d} x\) 是无穷小量，但不是零。在连续区域内，自变量增量取微分 \(\text{d}x\) 时，函数增量称为函数微分，记为 \(\text{d}y\)，它也是无穷小量，两者之间的关系为<br>$$<br>\text{d}y &#x3D; y(x + \text{d}x) - y(x)<br>$$</p><h3 id="1-5-微商（导数）"><a href="#1-5-微商（导数）" class="headerlink" title="1.5 微商（导数）"></a>1.5 微商（导数）</h3><p>自变量微分去除函数对应的微分，称为函数的微商，记作<br>$$<br>y’(x) &#x3D; \frac{\text{d}y}{\text{d}x}<br>$$</p><h4 id="1-5-1-函数泰勒展开"><a href="#1-5-1-函数泰勒展开" class="headerlink" title="1.5.1 函数泰勒展开"></a>1.5.1 函数泰勒展开</h4><p>导数可以用来将函数展开成幂级数的形式。</p><p>$$<br>y(x) &#x3D; A_0 + A_1(x - x_0) + A_2(x  -x_2)^2 + \dots<br>$$</p><p>上式中各个系数求解得到即 \(A_0&#x3D;y(x_0),A_n&#x3D;\frac{1}{n!}y^{[n]}(x_0),n&#x3D;1,2,\dots\)。当 \(x_0 &#x3D; 0\) 时，这样的泰勒级数也称为马克劳林级数。</p><p>常见的泰勒展开式如下：</p><p>$$<br>\begin{aligned}<br>\cos x &amp;&#x3D; 1 - \frac{1}{2!}x^2 + \frac{1}{4!}x^4 - \frac{1}{6!}x^6 + \dots \\<br>\sin x &amp;&#x3D; x - \frac{1}{3!}x^3 + \frac{1}{5!}x^5 - \frac{1}{7!}^7 + \dots \\<br>e^x &amp;&#x3D; 1 + x + \frac{1}{2!}x^2 + \frac{1}{3!}x^3 + \frac{1}{4!}x^4 +  \dots<br>\end{aligned}<br>$$</p><h4 id="1-5-2-矢量函数微商"><a href="#1-5-2-矢量函数微商" class="headerlink" title="1.5.2 矢量函数微商"></a>1.5.2 矢量函数微商</h4><p>标量与矢量的乘积为矢量，这一乘积对 \(t\) 求导可归结为矢量求导。</p><p>矢量 \(A(t)\) 与矢量 \(B(t)\) 的标积</p><p>$$<br>\mathbf A \cdot \mathbf B &#x3D; A_x B_x + A_y B_y + A_z B_z<br>$$</p><p>对 \(t\) 求导，为</p><p>$$<br>\frac{d(\mathbf A \cdot \mathbf B)}{dt} &#x3D; \frac{d \mathbf A}{dt}\cdot \mathbf B + \mathbf A \cdot \frac{d \mathbf B}{dt}<br>$$</p><p>对与 \(A\) 与 \(B\) 的矢量积，利用矢量积的展开式可以得到</p><p>$$<br>\frac{d(\mathbf A \times \mathbf B)}{dt} &#x3D; \frac{d \mathbf A}{dt} \times \mathbf B + \mathbf A \times \frac{d \mathbf B}{dt}<br>$$</p><h3 id="1-6-积分"><a href="#1-6-积分" class="headerlink" title="1.6 积分"></a>1.6 积分</h3><p>将 \(y\) 随 \(x\) 的变化关系和 \(y’\) 随 \(x\) 的变化关系分别记为 \(y &#x3D; \mathbf F(x)\) 和 \(y’ &#x3D; f(x)\)， 称 \(f(x)\) 是 \(F(x)\) 的导函数， \(F(x)\) 是 \(f(x)\) 的原函数。</p><p>$$<br>y_2 - y_1 &#x3D; \sum_{y_1}^{y_2} dy &#x3D; \sum_{x_1}^{x_2} f(x) dx<br>$$</p><p>将从 \(x_1\) 到 \(x_2\) 的区间分割成无穷多个小间隔 \(dx\)，相应地 \(y_1\) 到 \(y_2\) 区间也分割为无穷多个无穷小量间隔 \(dy\)，并引入积分符号表示</p><p>$$<br>\int_{x_1}^{x_2}f(x) dx &#x3D; \sum_{x_1}^{x_2} f(x) dx<br>$$</p><p>对于给定的 \(f(x)\) ，若能找到它的原函数 \(F(x)\)，便可获得上述定积分为</p><p>$$<br>\int_{x_1}^{x_2}f(x) dx &#x3D; \mathbf F(x_2) - \mathbf F(x_1)<br>$$</p><p>由 \(f(x)\) 找 \(F(x)\) 的运算可对应表示为</p><p>$$<br>\int f(x) dx &#x3D; F(x)<br>$$</p><p>称为 \(f(x)\) 的不定积分。不定积分是导数运算或者微商运算的逆运算。</p><h3 id="1-7-多元函数微积分"><a href="#1-7-多元函数微积分" class="headerlink" title="1.7 多元函数微积分"></a>1.7 多元函数微积分</h3><p>多元函数是由多个独立自变量构成的函数，将 \(k\) 个自变量的多元函数书写成</p><p>$$<br>y &#x3D; y(x_1, x_2, \dots， x_k)<br>$$</p><p>仅由自变量 \(x_1\) 的无穷小变化引起的函数增量</p><p>$$<br>y(x+dx_1, x_2, \dots, x_k) - y(x_1, x_2, \dots， x_k)<br>$$</p><p>称为函数对 \(x_1\) 的偏微分，将</p><p>$$<br>y’_{x_1} &#x3D;y(x+dx_1, x_2, \dots, x_k) - y(x_1, x_2, \dots， x_k) / dx_1<br>$$</p><p>称为函数对 \(x_1\) 的偏导数，在形式上与一元函数导数有所区别，将它书写成</p><p>$$<br>y’_{x_1} &#x3D; \frac{\partial y}{\partial x_1}<br>$$</p><p>以此类推可以得到对 \(x_i\) 的偏导数。</p><p>函数各自变量的变化引起的变化量称为全微分</p><p>$$<br>dy &#x3D; \frac{\partial y}{\partial x_1}dx_1  + \frac{\partial y}{\partial x_2}dx_2 + \dots + \frac{\partial y}{\partial x_k}dx_k<br>$$</p><h2 id="2-质点运动学"><a href="#2-质点运动学" class="headerlink" title="2. 质点运动学"></a>2. 质点运动学</h2><blockquote><p><strong>一个物体如何运动，不讨论如何运动是指点运动学讨论的问题</strong></p></blockquote><p>运动：物体个点部位的位置随时间的变化。</p><h3 id="1-1-空间与时间"><a href="#1-1-空间与时间" class="headerlink" title="1.1 空间与时间"></a>1.1 空间与时间</h3><h4 id="1-1-1-空间"><a href="#1-1-1-空间" class="headerlink" title="1.1.1 空间"></a>1.1.1 空间</h4><p>人类对空间的认识来源与物体在结构方面有前后、左右、上下三对可延展方向，物体运动也有这三对可移位的方向 \(\rightarrow\) 三维空间</p><p><strong>绝对空间观</strong>：</p><ul><li>存在没有物质的空间；</li><li>物质存在并且运动与这些空间内；</li><li>空间的的内在性质（三维欧几里得性质）与物质的存在运动与否无关。</li></ul><p><strong>相对论空间观</strong>：</p><ul><li>设想不存在物体的空间是没有意义的；</li><li>真实空间是物体延展而成而且运动所在的空间；</li><li>真实空间的度量性质随测量者（其载体是物体）而异。</li></ul><h4 id="1-1-2-时间"><a href="#1-1-2-时间" class="headerlink" title="1.1.2 时间"></a>1.1.2 时间</h4><p>时间观念的起源来自于物体运动形成的事物变化中状态出现的先后顺序性，时间即为此顺序性的量化表述。</p><p><strong>绝对时间观</strong>：</p><ul><li>存在着无事物演化的时间流失；</li><li>事物演化于该时间流逝中；</li><li>时间流逝的内在性质与事物的存在及演化的出现与否没有关系。</li></ul><p><strong>相对时间观</strong>：</p><ul><li>设想讨论不存在事物演化的时间是没有意义的；</li><li>真实的时间是事物的演化表现的时间；</li><li>真实时间的度量随着测量者而异。</li></ul><h4 id="1-1-3-参考系"><a href="#1-1-3-参考系" class="headerlink" title="1.1.3 参考系"></a>1.1.3 参考系</h4><p><strong>参考物</strong>：物体均处于相对运动状态之中, 最基本的运动关系便是两个物体之间的相对运动。</p><p><strong>参考空间</strong>：参考物在体结构上静态延展而成的三维空间（三维平直空间）。</p><p><strong>参考系</strong>：参考空间与时间的组合。</p><p><strong>空间坐标系</strong>：用来标定空间点位置，例如，直角坐标系、柱坐标系、球坐标系。</p><p><strong>质点模型</strong>：在参考系中，如果物体各个小部位截然不同，但其间差异相对考察的运动线度可忽略，便可用其中任意一点部位的运动来代表性的描述，这也可等效为将物体模型化为一个点。</p><p><strong>质点运动学</strong>：质点运动的数学描述。</p><h3 id="1-2-直线运动"><a href="#1-2-直线运动" class="headerlink" title="1.2 直线运动"></a>1.2 直线运动</h3><h4 id="1-2-1-位移-速度-加速度"><a href="#1-2-1-位移-速度-加速度" class="headerlink" title="1.2.1 位移 速度 加速度"></a>1.2.1 位移 速度 加速度</h4><p>质点相对于某参考系在一条直线上运动，在这一参考系中可将 \(x\) 坐标系设置在此直线上，质点运动过程中的位置 \(x\) 随时间 \(t\) 的变化关系表述成</p><p>$$<br>x &#x3D; x(t)<br>$$</p><p>这称为直线的运动方程。</p><p>从 \(t\) 时刻，经过 \(\Delta t\) 时间质点的位置差，简称<strong>位移</strong>。</p><p>$$<br>\Delta x &#x3D; x(t + \Delta t) - x(t)<br>$$</p><p>无穷小的时间间隔对应的位移式无穷小位移，记作 \(dx\)，有限段时间间隔 \(\Delta x\) 对应的位移 \(\Delta x\) 是一系列 \(dx\) 的叠加。</p><p>$$<br>\Delta x &#x3D; \sum_{t}^{t + \Delta t} dx &#x3D; \int_{t}^{t+\Delta t} dx<br>$$</p><p>路程 \(s\) 是另一个运动学量，意指 \(\Delta t\) 时间内质点经历的路线长度，计算公式为 </p><p>$$<br>s &#x3D; \sum_{t}^{t + \Delta t} |dx| &#x3D; \int_{t}^{t+\Delta t} |dx|<br>$$</p><p>取无穷小时间间隔量 \(dt\) 对应的 \(v\)，这一平均速度称为瞬时速度，简称<strong>速度</strong>，记作</p><p>$$<br>v &#x3D; \frac{dx}{dt}<br>$$</p><p>用<strong>加速度</strong>来描述速度的变化情况，定义为</p><p>$$<br>a &#x3D; \frac{dv}{dt}<br>$$</p><h4 id="1-2-2-三类直线运动"><a href="#1-2-2-三类直线运动" class="headerlink" title="1.2.2 三类直线运动"></a>1.2.2 三类直线运动</h4><p>直线运动可按照加速度分为零、常量、变量三种情况，分为匀速，匀加速，变加速三种类型。</p><p>匀加速直线运动过程中加速度是常量，记作</p><p>$$<br>a &#x3D; a_0<br>$$</p><p>如果 \(t_0 &#x3D; 0\) 时质点的速度为 \(v_0\)，位置为 \(x_0\)，可得</p><p>$$<br>\begin{aligned}<br>v &amp;&#x3D; v_0 + a_0t \\<br>x &amp;&#x3D; x_0 + v_0t + \frac{1}{2}at^2<br>\end{aligned}<br>$$</p><p>此外，利用</p><p>$$<br>a_0 &#x3D; \frac{dv}{dt} &#x3D; \frac{dv}{dx}\frac{dx}{dt} &#x3D; \frac{dv}{dx}v<br>$$</p><p>积分得到</p><p>$$<br>\begin{aligned}<br>\int_{v_0}^{v} v dv &amp;&#x3D; \int_{x_0}^{x} a dx \\<br>v^2 - v_0^2 &amp;&#x3D; 2a(x - x_0)<br>\end{aligned}<br>$$</p><p>常见的匀加速直线运动比如上抛运动，加速度方向竖直向下，大小为常量。</p><p>变加速直线运动过程中，加速度不是常量。宏观世界中影响物体的运动的因素众多，观察到的直线运动多数属于变加速运动。</p><h2 id="3-牛顿定律-动量定理"><a href="#3-牛顿定律-动量定理" class="headerlink" title="3. 牛顿定律 动量定理"></a>3. 牛顿定律 动量定理</h2><h2 id="4-机械能定理"><a href="#4-机械能定理" class="headerlink" title="4. 机械能定理"></a>4. 机械能定理</h2><h2 id="5-角动量定理-天体运动"><a href="#5-角动量定理-天体运动" class="headerlink" title="5. 角动量定理 天体运动"></a>5. 角动量定理 天体运动</h2><h2 id="6-质心-刚体"><a href="#6-质心-刚体" class="headerlink" title="6. 质心 刚体"></a>6. 质心 刚体</h2><h2 id="7-流体"><a href="#7-流体" class="headerlink" title="7. 流体"></a>7. 流体</h2><h2 id="8-振动和波"><a href="#8-振动和波" class="headerlink" title="8. 振动和波"></a>8. 振动和波</h2><h2 id="9-狭义相对论"><a href="#9-狭义相对论" class="headerlink" title="9. 狭义相对论"></a>9. 狭义相对论</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Physics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechanics </tag>
            
            <tag> Physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Essence of calculus</title>
      <link href="/posts/Essence-of-calculus.html"/>
      <url>/posts/Essence-of-calculus.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-导数的悖论"><a href="#1-导数的悖论" class="headerlink" title="1. 导数的悖论"></a>1. 导数的悖论</h2><blockquote><p>“So far as the theories of mathematics are about reality, they are not certain; so far as they are certain, they are not about reality.”  — Albert Einstein</p></blockquote><p>关于导数，人们通常认为它测量的是“ 瞬时变化率”。然而，这种说法本身存在一定的矛盾：变化需要在不同的时间点之间发生，而“ 瞬时” 意味着没有时间间隔，因此变化无从谈起。实际上，所谓的瞬时变化率本质上是一段极短时间内的平均变化率。导数正是通过极限的方式将这一微小时间间隔内的变化率定义为瞬时变化率，其数学表达式如下：<br>$$<br>\frac{ds}{dt}(t) &#x3D; \frac{s(t + dt) - s(t)}{dt}<br>$$</p><p>其中，\(dt\) 是一个有限小的量，虽然它不等于零，但非常接近于零。这种定义的优势在于，如果  \(dt\) 是一个确定的有限值，那么计算瞬时变化率的公式会变得非常复杂。例如：<br>$$<br>\frac{d(t^3)}{dt} &#x3D; \frac{t^3+3t^3+3t(dt)^2+(dt)^3-t^3}{dt}<br>$$<br>然而，如果 \(dt\) 是一个趋于零的量，那么就可以得到更加简洁的表达式：<br>$$<br>\frac{d(t^3)}{dt} &#x3D; 3 t^2<br>$$<br>这正是微积分实用性的精髓所在：通过极限的思想，将复杂的变化率问题简化为易于处理的数学形式。</p><h2 id="2-用几何来求导"><a href="#2-用几何来求导" class="headerlink" title="2. 用几何来求导"></a>2. 用几何来求导</h2><p>在大部分时间都要纠缠于抽象函数的导数，而不是考虑实实在在的变化率问题，这是因为许多现实世界中的现象或需要解决的问题都需要用到多项式，三角函数，指数函数或其他的纯函数来描述，因此假如能够熟练掌握抽象函数的变化率思想，那你就学到了如果精准描述事物变化率的语言。</p><p>但是要把这个过程说的像是要记住一系列公式的话，那么就很容易忘记。导数的实质是要看某个量的微小变化，以及它和它所导致的另一个量的微小变化有什么关系。接下来将会讲述如何可视化又直观的考虑其中的一些导数公式。</p><h3 id="2-1-x-2-的导数"><a href="#2-1-x-2-的导数" class="headerlink" title="2.1 \(~x^2\) 的导数"></a>2.1 \(~x^2\) 的导数</h3><p>首先让我们从几何的角度来理解函数 \(f(x) &#x3D; x^2\) 的导数。直观上，\(x^2\) 可以表示一个边长为 \(x\) 的正方形的面积。假如给 \(x\) 一个微小的增量 \(dx\) ，那么正方形面积会增加多少？这个面积的增量就是 \(df\)，即由 \(x\) 的微小增量 \(dx\) 引起的 \(f(x)&#x3D;x^2\) 的值的微小增加量。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/calculas202503171543779.png" width="500" alt="图1 正方形面积变化量"/><p>具体来说，面积的增量由三部分组成：所以它们组成了 \(2x\text{d}x + (\text{d}x)^2\) 的新面积。根据定义 \(dx\) 实际上是一个非常非常微小的值。 因此可以忽略掉任何包含多余一个 \(\text{d}x\) 的项。 所以最终得到的 \(df\) 就是：</p><p>$$<br>\text{d}f &#x3D; 2x\text{d}x<br>$$</p><p>从而可以计算得出 \(f(x) &#x3D; x^2\) 的导数。</p><p>$$<br>\frac{\text{d}f}{\text{d}x} &#x3D; 2 x<br>$$</p><h3 id="2-2-x-3-的导数"><a href="#2-2-x-3-的导数" class="headerlink" title="2.2 \(~x^3\) 的导数"></a>2.2 \(~x^3\) 的导数</h3><p>同样地，可以从几何的角度来理解函数 \(f(x) &#x3D; x^3\) 的导数。\(x^3\) 可以表示一个边长为 \(x\) 的立方体的体积。当给 \(x\) 一个微小的增量 \(dx\)，立方体的体积变化量可以通过以图 2 直观地表示：</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/calculas202503171602235.png" width="400" alt="图2 立方体体积变化量"/><p>从图中可以观察到，体积的主要变化来自三个互相垂直的外扩正方形面。因此，我们可以近似计算体积的增量 \(df\) 为：</p><p>$$<br>\text{d} f &#x3D; 3x^2 \text{d}x<br>$$</p><p>从而可以计算得出 \(x^3\) 的导数。</p><p>$$<br>\frac{\text{d}f}{\text{d}x} &#x3D; 3x^2<br>$$</p><h3 id="2-3-x-n-的导数"><a href="#2-3-x-n-的导数" class="headerlink" title="2.3 \(~x^n\) 的导数"></a>2.3 \(~x^n\) 的导数</h3><p>在现实中，你不需要在每次求 \(x^2\) 的导数时都要想象一个正方形，在求 \(x^3\) 的导数的时候想象一个正方体。因为这两者都遵循一个关于幂函数的规律<br>$$<br>\frac{d(x^n)}{dx} &#x3D; nx^{n-1}<br>$$</p><p>让我们来思考一下为什么幂函数求导也适用于 2 和 3 以外的指数。假如稍微增加 \(x\) 到 \(x+dx\)， 那么想要求出 \((x+dx)^n\) 的函数值就需要把这 \(n\) 个 \(x+dx\) 全部乘到一起。这个完整的展开式会很复杂，但是求导的一个关键点就是很大一部分项可以被忽略。</p><p>$$<br>\begin{aligned}<br>(x+dx)^n &amp;&#x3D; \overbrace{(x+dx)(x+dx)…(x+dx)} ^{n个}\\<br>&amp;&#x3D; x^n + nx^{n-1}dx+(…)dx^2<br>\end{aligned}<br>$$</p><p>将 \(dx^2\) 及更高次项忽略就可以得到 \(d{(x^n)}\) 的近似关系：</p><p>$$<br>d(x^n) &#x3D; nx^{n-1}dx<br>$$</p><p>这就推导出了幂函数的求导公式。由此可见，幂函数的求导法则在更一般的情况下依然成立。</p><h3 id="2-4-1-x-的导数"><a href="#2-4-1-x-的导数" class="headerlink" title="2.4    \(~1&#x2F;x\)的导数"></a>2.4    \(~1&#x2F;x\)的导数</h3><p>现在考虑 \(\frac{1}{x}\) 的导数。一方面讲，可以简单粗暴地尝试应用幂函数求导公式。那么现在让我们看看能不能从几何的角度去考虑这个问题，而不是单单把它代入到公式中。</p><p>\(\frac{1}{x}\) 的值也就是在问“ 什么数乘以 \(x\) 等于 \(1\)?”。 从几何角度上，可以想象在二维平面上面积为 \(1\) 的长方形。假设它的宽度是 \(x\)，那么它的高度必然就是 \(\frac{1}{x}\)。假设给 \(x\) 一个微小的增量 \(dx\)，那么想让长方形的面积保持为 \(1\) 的话，它的高度应该如何变化呢？</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/calculas202503201854552.png" width="500" alt="图3 长方形面积变化图"/><p>显然，增加了 \(dx\) 的宽度就会在右边的位置增加一点新的面积，所以原本矩阵的高度就需要按照 \(d(1&#x2F;x)\) 减少，使得顶部面积的减少会与右边面积增加相抵。那么就可以得到如下关系：</p><p>$$<br>\begin{aligned}<br>x\text{d}(1&#x2F;x) &amp;&#x3D; \frac{\text{d}x}{x} \\<br>\frac{\text{d}(1&#x2F;x)}{\text{d}x} &amp;&#x3D; \frac{1}{x^2}<br>\end{aligned}<br>$$</p><p>得到 \(1&#x2F;x\) 的导数结果与幂函数求导法则得到的结果一致。</p><h3 id="2-5-sqrt-x-的导数"><a href="#2-5-sqrt-x-的导数" class="headerlink" title="2.5 \(~\sqrt{x}\)的导数"></a>2.5 \(~\sqrt{x}\)的导数</h3><p>同样，我们可以通过几何方法求解 \(\sqrt{x}\) 的导数。考虑如图 4 所示的正方形，其面积为 \(x\)。如果对面积 \(x\) 施加一个微小的增量 \(\text{d}x\)，则对应的正方形边长的增量即为 \(\text{d}\sqrt{x}\)。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/calculas202503201916385.png" width="400" alt="图4 正方形面积变化图"/><p>由面积变化的关系可得，新增的面积 \(\text{d}x\) 由两侧的小矩形面积及右下角的小正方形面积之和组成，因此有：</p><p>$$<br>\text{d}x &#x3D; 2\sqrt{x}\text{d}\sqrt{x} + (\text{d}\sqrt{x})^2<br>$$</p><p>忽略 \((\text{d}\sqrt{x})^2\) 这一高阶小量，并整理得：</p><p>$$<br>\frac{\text{d}\sqrt{x}}{\text{d}x} &#x3D; \frac{1}{2\sqrt{x}}<br>$$</p><p>这一结果与幂函数求导法则一致，进一步验证了其正确性。</p><h3 id="2-6-sin-theta-的导数"><a href="#2-6-sin-theta-的导数" class="headerlink" title="2.6 \(~\sin (\theta)\) 的导数"></a>2.6 \(~\sin (\theta)\) 的导数</h3><p>最后，我们来探讨三角函数的导数，以正弦函数为例。首先，补充单位圆下的三角函数表示方式：对于某个给定的角 \(\theta\) 值，其对应的 \(\sin(\theta)\) 值即为单位圆上该点到 \(x\) 轴的垂直高度。当 \(\theta\) 增加时，你会不停在圆上行走， 其高度就会在\(-1\)到\(1\)之间上下摆动。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/calculas202503201943524.png" width="500" alt="图5 三角函数在单位圆下的表示"/><p>想要对三角函数的导数有一个更准确的认识，就需要看函数的真实含义。 假设在圆周上的一个微小行进量 \(\text{d}\theta\)，它将使得 \(\sin{\theta}\) 改变多少？首先，在一个足够大的尺度下，圆看上去就像是条直线，所以我们来考虑图\(6\)这个直角三角形。  </p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/calculas202503201954322.png" width="500" alt="图6 在单位圆下几何微小的行进量"/><p>其中斜边表示的是圆周上的微小行进量 \(d\theta\)，左边的这条表示的是高度的变化量 \(\text{d}(\sin(\theta))\)。这个三角形和这大的三角形相似，所以其上方的小角就等于 \(\theta\)。现在，来想想正弦函数的导数应该等于什么？应该等于 \(\text{d}(\sin(x))&#x2F;\text{d}x\)，根据图中几何关系可知这个比值的结果为 \(\cos(\theta)\)。即：</p><p>$$<br>\frac{\text{d}\sin(x)}{\text{d}x} &#x3D; \cos x<br>$$</p><h2 id="3-直观理解加法法则、乘法法则与链式法则"><a href="#3-直观理解加法法则、乘法法则与链式法则" class="headerlink" title="3. 直观理解加法法则、乘法法则与链式法则"></a>3. 直观理解加法法则、乘法法则与链式法则</h2><p>在上一节中，我们通过直观的方法讲解了如何对初等函数进行求导。本节的目标是在此基础上，进一步理解更复杂的组合函数的求导方法。与其机械地记忆每条求导法则的公式，我们将继续从几何的角度出发，探讨每条法则背后的几何意义，以加深对导数本质的理解。</p><p>复杂函数可以归结为三种组合函数的基本方法：<strong>函数相加</strong>，<strong>函数相乘</strong>以及<strong>函数套函数（复合函数）</strong>。只要能够掌握了三种组合方式的导数，就能将一个庞大的表达式一层层剥离，一步步求导。</p><h3 id="3-1-加法法则"><a href="#3-1-加法法则" class="headerlink" title="3.1 加法法则"></a>3.1 加法法则</h3><p>首先来看加法法则，两个函数的和的导数就是它们导数的和。为了证明这一点，我们以函数 \(f(x) &#x3D; \sin(x) + x^2\) 为例。对于每个变量取值上，你就把 \(\sin(x)\) 和 \(x^2\) 对应的函数值相加。考虑这个函数自变量 \(x\) 的一个微小变化量 \(\text{d}x\)，整个函数的变化量记作 \(\text{d}f\)，其值应该等于 \(\sin(x)\) 的变化量 \(\text{d}(\sin(x))\) 加上 \(\text{d}x\) 的变化量 \(\text{d}(x^2)\)。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/calculas202503202034673.png" width="500" alt="图7 加法法则"/><p>因此可以归纳得到加法法则：</p><p>$$<br>\frac{\text{d}}{\text{d}x}(g(x)+h(x)) &#x3D; \frac{\text{d}g}{\text{d}x} + \frac{\text{d}h}{\text{d}x}<br>$$</p><h3 id="3-2-乘积法则"><a href="#3-2-乘积法则" class="headerlink" title="3.2 乘积法则"></a>3.2 乘积法则</h3><p>乘积法则的情况则有些不同。类似地，我们来通过微小的变化思考原因。这里，使用图像不是可视化的最佳方式，在不同层次的数学中，一个相当常见的做法是：如果要处理两个东西的乘积，通过面积来理解会有好处。让我们以 \(f(x) &#x3D; \sin(x)x^2\) 为例，考虑 \(x\) 的微小变化 \(\text{d}x\) 将如何影响面积。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/calculas202503202215618.png" width="500" alt="图8 乘法法则图示"/><p>根据上图可以计算得到 \(\text{d}f\) 的变化量为：</p><p>$$<br>\begin{aligned}<br>\text{d}f &amp;&#x3D; \sin(x)\text{d}(x^2) + x^2 \text{d}(\sin(x)) + (…)(\text{d}x)^2 \\<br>\frac{\text{d}f}{\text{d}x} &amp;&#x3D; \sin(x) 2x + x^2 \cos(x)<br>\end{aligned}<br>$$</p><p>因此可以得到乘法法则：</p><p>$$<br>\frac{\text{d}f}{\text{d}x} &#x3D; g(x)\frac{\text{d}h}{\text{d}x} + h(x)\frac{\text{d}g}{\text{d}x}<br>$$</p><h3 id="3-3-链式法则"><a href="#3-3-链式法则" class="headerlink" title="3.3 链式法则"></a>3.3 链式法则</h3><p>还有一种常见的函数组合方式，它出现得极为频繁，那就是把一个函数塞到另一个里面，也叫做函数复合。例如 \(g(x) &#x3D; \sin(x), h(x) &#x3D; x^2\)，那么将两个函数复合就能得到：</p><p>$$<br>g(h(x)) &#x3D; \sin(x^2)<br>$$</p><p>现在我们从数轴的角度来分析复合函数如何求导。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/calculas202503202312875.png" width="500" alt="图9 复合函数图示"/><p>想要计算导数，还是要让 \(x\) 的值稍稍变化 \(dx\) 的量，它所导致的第二个值的变化量，即 \(dx\) 引起的 \(x^2\) 的变化就是 \(d(x^2)\)，将其展开就可以得到 \(2x\text{d}x\)。同样考虑 \(\text{d}(x^2)\) 的变化量对 \(\sin(x^2)\) 的变化，即为 \(\text{d}(\sin(x^2))\)，将该式展开可得：</p><p>$$<br>\text{d}(\sin(x^2)) &#x3D; \cos (x^2) \text{d}(x^2) &#x3D; \cos(x^2) 2x \text{d}x<br>$$</p><p>因此可以归纳总结出复合函数的求导法则，其又被称为“ 链式法则” 。</p><p>$$<br>\frac{\text{d}}{\text{d}x} g(h(x)) &#x3D; \frac{\text{d}g}{\text{d}h}(h(x))\frac{\text{d}h}{\text{d}x}(x)<br>$$</p><p>该式子是在描述输出量 \(g\) 的微小变化除以 \(h\) 的微小变化是多少，然后乘以 \(h\) 的微小变化与 \(x\) 的微小变化的比值，这些 \(\text{d}h\) 最终将会消去，结果就是输出值 \(g\) 的微小变化与输入值 \(x\) 的微小变化的比值。</p><h2 id="4-指数函数求导"><a href="#4-指数函数求导" class="headerlink" title="4. 指数函数求导"></a>4. 指数函数求导</h2><p>这一节中来谈一谈诸如 \(2^x, 7^x\) 之类的函数的导数，并阐明为什么 \(e^x\) 是指数函数中最重要的一个。 我们以 \(M(t) &#x3D; 2^t\) 为例子，根据导数的定义计算其导数为：</p><p>$$<br>\frac{\text{d}M}{\text{d}t}(t) &#x3D; \frac{2^{t + \text{d}t} - 2^t}{\text{d}t} &#x3D; \frac{2^t2^{\text{d}t}-2^t}{\text{d}t} &#x3D; 2^t(\frac{2^{\text{d}t} - 1}{\text{d}t})<br>$$</p><p>从上式可以看出，右边括号中的项与 \(t\) 无关。当 \(\text{d}t\) 取极小值时，该项会趋近于一个特定的常数，大约为 \(0.6931472…\)。</p><p>这个性质并不是 \(2^t\) 独有的，如果尝试替换成其他函数，例如 \(3^t\)，能够发现这个常数变成了 \(1.0986…\)。那么，从根本上来看，这些“ 神秘常数” 到底从何而来？是否存在某个特殊的底数，使得导数中的这个系数恰好等于 \(1\) 呢？换句话说，是否有某个 \(a\) 使得 \(a^t\) 的导数不仅仅与自身成比例，而是完全等于自身？</p><p>有的兄弟有的，它就是特殊的常量 \(\text{e}\)，大约是 \(2.71828…\)。事实上，常数 \(\text{e}\) 并不是碰巧出现在这里的，\(\text{e}\) 的诞生正是源于这种自然增长的数学需求，使得指数函数 \(e^t\) 拥有最简洁、最优雅的导数公式：</p><p>$$<br>\frac{\text{d}}{\text{d}t} e^t &#x3D; e^t<br>$$</p><p>现在，我们可以借助 \(e\) 来进一步研究那些导数与自身成正比的函数。根据链式法则，可以推导出以下公式：</p><p>$$<br>\frac{\text{d}(e^{ct})}{\text{d}t} &#x3D; ce^{ct}<br>$$</p><p>接下来，我们将 \(2\) 重新表达为 \(e^{\ln 2}\)，这一转换正是基于自然对数的定义。因此，可以将 \(2^t\) 改写为：</p><p>$$<br>2^t &#x3D; e^{\ln(2)t}<br>$$</p><p>此时，根据上面推导出的导数公式，我们可以得到：</p><p>$$<br>\frac{\text{d}}{\text{d}x} 2^t &#x3D; \ln(2) 2^t<br>$$</p><p> 其中，\(\ln(2)\) 的数值正是先前计算出的神秘常数 \(0.6931472…\)。这表明，不同底数的指数函数，其导数中的比例因子正是该底数的自然对数。至此可以归纳得到指数函数的求导公式：</p><p> $$<br> \frac{\text{d}(a^x)}{\text{d}x} &#x3D; \ln(a) a^t<br> $$</p><h2 id="5-隐函数求导"><a href="#5-隐函数求导" class="headerlink" title="5. 隐函数求导"></a>5. 隐函数求导</h2><h3 id="5-1-求圆切线问题"><a href="#5-1-求圆切线问题" class="headerlink" title="5.1 求圆切线问题"></a>5.1 求圆切线问题</h3><p> 这一节我们来谈一谈什么是隐函数求导，我们从 \(xy\) 直角坐标系的原点为圆心做一个半径为 \(5\) 的圆说起。这个圆可以用如下等式表示：</p><p> $$<br> x^2 + y^2 &#x3D; 5<br> $$</p><p>即这个圆上所有的点离原点的距离都是 \(5\) 。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/calculas202503221433326.png" width="500" alt="图10 圆上的变化率"/><p>我们对等式两边微分可得：</p><p>$$<br>\begin{aligned}<br>2x\text{d}x + 2y\text{d}y &amp;&#x3D; 0 \\<br>\frac{\text{d}y}{\text{d}x} &#x3D; -\frac{x}{y}<br>\end{aligned}<br>$$</p><p>在求解圆上某点的变化率时，我们面临一个不同于传统微积分中切线斜率的问题。由于圆的方程不是一个单变量函数，它无法通过单纯的求导来描述自变量的微小变化如何影响函数值的微小变化。因此，我们需要引入新的方法来处理这一类问题。在正式解决圆上点的变化率之前，我们先来看一个相关的变化率问题。</p><h3 id="5-2-梯子滑动问题"><a href="#5-2-梯子滑动问题" class="headerlink" title="5.2 梯子滑动问题"></a>5.2 梯子滑动问题</h3><p>现在有一把 \(5\) 米长的梯子斜靠在墙上，梯子的顶端开始以 \(1\) 米每秒的速度下滑，请问在这一开始的瞬间，梯子底端离开墙角的速度是多少？为了解决这个问题，我们令梯子顶端离地的距离标积为函数 \(y(t)\)，底部离墙的距离就标积为函数 \(x(t)\)，两个函数可由一个关键等式联系起来：</p><p>$$<br>x(t)^2 + y(t)^2 &#x3D; 5^2<br>$$</p><p>现在我们这样考虑求解这个问题，等式的左边我们认为其是一个关于时间的函数，它正好等于一个常数，即它的值是不随时间而改变的，但依然把它写成了一个关于时间的式子。这就表示我们能把它当作关于 \(t\) 的函数对待。对等式两侧对 \(t\) 求导可得：</p><p>$$<br>\begin{aligned}<br>\frac{d(x(t)^2+y(t)^2)}{dt} &amp;&#x3D; 0 \\<br>2x(t)\frac{dx}{dt} + 2y(t)\frac{dy}{dt} &amp;&#x3D; 0<br>\end{aligned}<br>$$</p><p>根据上式即可得到梯子底端的速度。</p><h3 id="5-3-求切线问题和梯子滑动问题的联系"><a href="#5-3-求切线问题和梯子滑动问题的联系" class="headerlink" title="5.3 求切线问题和梯子滑动问题的联系"></a>5.3 求切线问题和梯子滑动问题的联系</h3><p>在解决梯子滑动问题时，我们发现它与求圆的切线问题存在一定的相似性。在这两个问题中，都涉及到同一个等式： \(x^2 +y^2 &#x3D; 5^2\)。在求解时，我们的策略都是对这个等式的两边求导。然而，二者在求导时的背景有所不同。</p><p>在梯子滑动问题中，\(x\) 和 \(y\) 都是关于时间 \(t\) 的函数，即 \(x &#x3D; x(t)\)、\(y &#x3D; y(t)\)。对等式两侧求导的过程实际上是在研究变量随时间的变化率，因此微分具有清晰的物理意义。</p><p>然而，在求圆的切线问题时，我们并没有显式地引入时间 \(t\)，而是直接研究变量 \(x\) 和 \(y\) 之间的关系。此时，微分的意义似乎变得不那么直观——我们不再考虑一个微小的时间变化 \(dt\) 如何影响 \(x\) 和 \(y\)，而是直接分析 \(x\) 和 \(y\) 的瞬间变化率之间的关系。这种方法实际上对应的是隐函数求导，它帮助我们在不显式引入时间参数的情况下，找到变量之间的变化规律。</p><p>接下来，我们就用这种方法来解答圆的切线问题。首先给表达式 \(x^2 + y^2\) 取个名字为 \(S\)，其实际上就是取两个变量的函数，对于平面每一点 \(x, y\) 它都会返回一个值。在研究圆的切线时，我们关注的是 \(S\) 在曲线上如何变化。求导的关键在于，我们需要考虑 \(S\) 的两个变量 \(x\) 和 \(y\) 同时 发生微小变化。也就是说，既有 \(x\) 的微小变化量 \(dx\)，也有 \(y\) 的微小变化量 \(dy\)。然而，由于这些变化仍然发生在圆上，我们要求它们保持满足原方程 \(S &#x3D; 5^2\) 的约束，这意味着 \(d(S) &#x3D; 0\)。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/calculas202503221549638.png" width="500" alt="图11 圆上微小变化量变化"/><h2 id="6-极限"><a href="#6-极限" class="headerlink" title="6. 极限"></a>6. 极限</h2><p>在前面的几个小节中，我们主要讨论了如何求导。而在正式讲解积分之前，我们先补充一个关键概念—— 极限。</p><p>极限的基本思想并不陌生，它描述的是一个数值如何逐渐逼近另一个数值。然而，极限不仅仅是“无限接近”这么简单的直觉概念，它还为数学分析提供了严格的基础。接下来，我们将借助极限的定义来解释以下三个关键内容：</p><ul><li>重新审视导数的定义，并理解其本质；</li><li>利用极限的 \(\varepsilon - \delta\) 形式化定义，深入剖析“逼近”的精确含义；</li><li>洛必达法则。</li></ul><h3 id="6-1-导数的定义"><a href="#6-1-导数的定义" class="headerlink" title="6.1 导数的定义"></a>6.1 导数的定义</h3><p>在极限的框架下，导数的正式定义如下：</p><p>$$<br>\frac{df}{dx}(x) &#x3D; \lim_{h \rightarrow 0}\frac{f(x + h) - f(x)}{h}<br>$$</p><p>从这个表达式可以看出，右侧的极限形式彻底避免了“无穷小”概念可能带来的悖论。事实上，引入极限的目的正是为了严格定义导数，同时避免逻辑上的矛盾。在理解导数时，不同的人可能会对符号 \(dx\) 产生不同的解读：</p><ul><li>有人将 \(dx\) 视为一个无穷小的变化量；</li><li>也有人认为 \(dx\) 和 \(df\) 只是单纯的数学符号，没有特定的数值意义。</li></ul><p>实际上，这两种解读都不够严谨。更准确的理解是：\(dx\) 代表一个具体的、有限的变化量，而导数的求解过程关注的是当 \(dx\) 逐渐趋近于零时的极限行为。这种用有限的变化量描述导数的思想，实际上与导数的正式定义是完全等价的。</p><h3 id="6-2-极限的定义"><a href="#6-2-极限的定义" class="headerlink" title="6.2 极限的定义"></a>6.2 极限的定义</h3><p>以函数 \(\frac{(2 + h)^3 - (2)^3}{h}\) 为例，它的图像看着像是一条连续的抛物线。可以发现这个函数当 \(x &#x3D; 0\) 时，函数没有定义。但实际上，当输入无限接近 \(0\) 的时候，函数仍然是有定义的。当 \(h\) 逼近于 \(0\) 的时候，函数的值将会逼近于 \(12\)，这种结果与函数从哪边逼近无关。</p><p>在数学分析中，极限的定义通常采用 \(\varepsilon - \delta\) 语言来表述。在这个例子中，我们讨论函数在 \(0\) 处的极限值为 \(12\)。为了描述任意函数值与 \(12\) 之间的距离，习惯上使用 \(\varepsilon\) 来表示这段距离，并且 \(\varepsilon\) 可以任意小。</p><p>极限存在的核心条件是：在 \(0\) 的邻域内，始终可以找到一个 \(\delta\)，使得当自变量落在 \(0\) 附近、距离不超过 \(\delta\) 时，函数值始终处于 \(12\) 的 \(\varepsilon\) 邻域内。关键在于，这种情况对于任意小的 \(\varepsilon\) 都成立，即无论 \(\varepsilon\) 取多小，总能找到合适的 \(\delta\)，确保函数值保持在 \(12\) 的 \(\varepsilon\) 范围内。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/download.png" width="500" alt="图12 极限的定义"/><h3 id="6-3-洛必达法则"><a href="#6-3-洛必达法则" class="headerlink" title="6.3 洛必达法则"></a>6.3 洛必达法则</h3><p> 假设要求解如下极限值：</p><p>$$<br> \lim_{x \rightarrow 1} \frac{\sin(\pi x)}{x^2 - 1}<br>$$</p><p>通过代入 \(1\) 可以发现 \(\frac{\sin(\pi)}{1^2-1} \rightarrow \frac{0}{0}\)。想要求解这个极限就需要用到导数。考虑某个微小的变化量 \(dx\) 对其的影响，\(\sin(\pi x)\) 会减少，变化量 \(dx\) 对函数造成的影响就是这个函数值的变化量，称为 \(d(\sin(\pi x))\)，根据链式法则微分得到 \(\cos(\pi x)\pi dx\)。同样的 \(x^2 - 1\) 的图像变化量为 \(d(x^2 - 1)\)，微分得到 \(2xdx\)。因此可以得到：</p><p>$$<br> \lim_{x \rightarrow 1} \frac{\sin(\pi x)}{x^2 - 1} \approx \frac{-\pi dx}{2dx} &#x3D; \frac{-\pi}{2}<br>$$</p><p>归纳以上的推导过程就可以得到洛必达法则的一般形式：</p><p>$$<br>\lim_{x \rightarrow a}\frac{f(x)}{g(x)} &#x3D; \frac{f’(a)}{g’(x)}<br>$$</p><h2 id="7-积分与微积分基本定理"><a href="#7-积分与微积分基本定理" class="headerlink" title="7. 积分与微积分基本定理"></a>7. 积分与微积分基本定理</h2><p>积分本质上是求导的逆运算，我们可以通过一个例子来说明这一点。在前面的小节中，我们利用距离-时间函数的导数得到了速度-时间函数。同样，在当前情境下，如果已知速度函数并希望求得距离-时间函数，本质上就是在思考：哪个函数的导数等于给定的速度函数？</p><p>但在此之前，我们首先需要说明这一问题如何与求由速度函数围成的面积相关联。这种联系不仅有助于建立对问题的直观理解，还能为我们探索更广泛的数学概念奠定基础。这类问题统称为“ 积分问题”，它们在数学分析和应用中扮演着至关重要的角色。在速度-时间函数的情境下，求解积分实际上意味着计算物体在某一时间段内所经过的总距离。如果要计算 \(0\sim 8\) 秒经过的距离表示为：</p><p>$$<br>\int_0^8 v(t) dt<br>$$</p><p>其中 \(dt\) 趋近于 \(0\)，其在几何上的表现为如下函数图像于坐标轴为围成的面积。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures@main/image.png" width="500" alt="图13 积分的几何表示"/><p>在车速问题的动力学分析中，我们可将时间区间的右端点扩展为自变量 \( T \)，从而构建一个以时间为变量的路程函数。具体而言，设速度函数 \( v(t) \) 在时域 \( [0, T] \) 上的积分为：</p><p>$$<br>s(T) &#x3D; \int_0^T v(t) dt<br>$$</p><p>该积分在几何上表现为速度-时间曲线与横轴所围区域的面积值，其物理意义对应车辆在 \( T \) 秒内的总位移。若对此路程函数进行微分分析，可通过极限过程揭示其导数特性：当时间变量产生微小增量 \( dT \) 时，对应的位移增量 \( ds \) 在数值上等于底为 \( dT \)、高为 \( v(T) \) 的矩形面积，即：</p><p>$$<br>ds &#x3D; v(T) dT<br>$$</p><p>由此直接导出微分关系：</p><p>$$<br>\frac{ds}{dT} &#x3D; v(T)<br>$$</p><p>这一结论实质上是微积分基本定理（Fundamental Theorem of Calculus）的具体表现，它严格证明了可积函数 \( v(t) \) 的变上限积分对上限变量的导数等于被积函数在上限处的函数值。更一般地，该定理建立了积分与微分之间的对偶关系：任一连续函数图像下方面关于积分上限的导数，恒等于该函数在积分上限处的取值。</p><p>推广至一般情景，对于任意函数 \(f(x)\) 求积分时，你是在把 \(x\) 在一定范围内的所有 \(f(x)dx\) 值加起来，然后求 \(dx\) 趋近于 \(0\) 时，加和趋近的值。求积分的第一步是找原函数，也就另一个函数 \(F(x)\)，并满足：</p><p>$$<br>\frac{dF}{dx}(x) &#x3D; f(x)<br>$$</p><p>则积分值就等于原函数在上限时的值减去下限的值：</p><p>$$<br>\int_a^b f(x)dx &#x3D; F(b) - F(a)<br>$$</p><p>这就是所谓的微积分基本定理。在积分的过程把面积切分为很小的矩形面积的和的极限，连续的遍历所以矩形面积的值，然而利用原函数求值的时候只关注两个自变量上限和下限。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Mathematic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> Calculus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning for computer vision</title>
      <link href="/posts/Deep-Learning-for-computer-vision.html"/>
      <url>/posts/Deep-Learning-for-computer-vision.html</url>
      
        <content type="html"><![CDATA[<h2 id="Lecture3-Linear-Classifiers"><a href="#Lecture3-Linear-Classifiers" class="headerlink" title="Lecture3: Linear Classifiers"></a>Lecture3: Linear Classifiers</h2><h3 id="1-Linear-classifier"><a href="#1-Linear-classifier" class="headerlink" title="1. Linear classifier"></a>1. Linear classifier</h3><p>There are three ways to think about linear classifiers:</p><ul><li>Algebraic viewpoint</li><li>Visual viewpoint</li><li>Geometric viewpoint</li></ul><h3 id="2-Loss-function"><a href="#2-Loss-function" class="headerlink" title="2. Loss function"></a>2. Loss function</h3><p>A loss function tells how good our classifier is </p><ul><li>Low loss \(\rightarrow\) A good classifier</li><li>High loss \(\rightarrow\) A bad classifier</li></ul><p>Given a dataset of examples \(\{(x_i, y_i)\}^N_{i&#x3D;1}\), where \(x_i\) is image and \(y_i\) is integer label.</p><p>Loss for a single example is </p><p>$$<br>L_i(f(x_i, W), y_i)<br>$$<br>Loss for the dataset is average of per-example losses:</p><p>$$<br>L &#x3D; \frac{1}{N} \sum_{i}{L_i(f(x_i, W), y_i)}<br>$$</p><p>Next we will introduce some commonly used loss function.</p><h4 id="2-1-Cross-Entropy-Loss"><a href="#2-1-Cross-Entropy-Loss" class="headerlink" title="2.1 Cross-Entropy Loss"></a>2.1 Cross-Entropy Loss</h4><p>The Cross Entropy Loss is also called Multinomial Logistic Regression. Its main idea is to interpret the raw classifier scores as <strong>probabilities</strong>. The formula is as follows:</p><p>$$<br>L_i &#x3D; -\log P(Y&#x3D;y_i|X&#x3D;x_i)<br>$$</p><p>where the \(P(Y &#x3D; y_i|X&#x3D;x_i)\) is a <strong>Softmax function</strong>, which formula is as follows:</p><p>$$<br>P(Y &#x3D; k| X&#x3D; x_i) &#x3D; \frac{\text{exp}(s_k)}{\sum_j{\text{exp}(s_j)}}<br>$$</p><blockquote><p><strong>Q:</strong> What is the min &#x2F; max possible loss \(L_i\) ?</p></blockquote><p>The minimal \(L_i\) is \(0\) and the maximum \(L_i\) is \(+\infty\).</p><h4 id="2-2-Multi-class-SVM-Loss"><a href="#2-2-Multi-class-SVM-Loss" class="headerlink" title="2.2 Multi-class SVM Loss"></a>2.2 Multi-class SVM Loss</h4><p>The core idea of multi-class SVM loss is the score of the correct class should be higher than all the other scores.</p><p>Given an example \((x_i, y_i)\), where \(x_i\) is image and \(y_i\) is label. Let \(s &#x3D; f(x_i, W)\) be the score vector. Then, the SVM loss has the following form:</p><p>$$<br>L_i &#x3D; \sum_{j \ne y_i} \max({0, s_j - s_{y_i} + 1})<br>$$</p><h2 id="Lecture-4-Regularization-Optimization"><a href="#Lecture-4-Regularization-Optimization" class="headerlink" title="Lecture 4: Regularization &amp; Optimization"></a>Lecture 4: Regularization &amp; Optimization</h2><h3 id="1-Regularization"><a href="#1-Regularization" class="headerlink" title="1. Regularization"></a>1. Regularization</h3><blockquote><p>What is <strong>Overfitting</strong> ?</p></blockquote><p>A model is <strong>overfitting</strong> when it performs too well on the training data, and has poor performance for unseen data.</p><p>To alleviate the effort of overfitting, we use the regularization term to prevent the model form performing too well on training data.  The new loss function is as follows:</p><p>$$<br>L(W) &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^{N}L_i(f(x_i, W), y_i) + \lambda R(W)<br>$$</p><p>where \(\lambda\) is a hyper-parameter giving regularization strength.</p><p>Regularization term causes loss to increase for model with sharp cliff. There are some commonly used regularization term:</p><ul><li>\(L2\) regularization: \(R(W) &#x3D; \sum_{k,l}W^2_{k,l}\)</li><li>\(L1\) regularization: \(R(W) &#x3D; \sum_{k,l}|W_{k,l}|\)</li></ul><blockquote><p>Other regularization methods</p></blockquote><ul><li>Dropout</li><li>Batch normalization</li><li>Cutout, Mixup, Stochastic depth, etc…</li></ul><h3 id="2-Optimization"><a href="#2-Optimization" class="headerlink" title="2. Optimization"></a>2. Optimization</h3><p>The core idea of optimization is to minimize the loss function by optimizing the weight matrix, and the formula is as follows:</p><p>$$<br>W^{*} &#x3D; \arg \min_{w} L(W)<br>$$</p><p>In order to optimize the weight matrix, we should choose an effective strategy. A simple yet effective approach is following the slope. In multiple dimensions, the gradient is the vector of along each dimension. </p><blockquote><p>How to compute gradient?</p></blockquote><ul><li><strong>Numeric gradient</strong>: approximate, slow, easy to write</li><li><strong>Analytic gradient</strong>: exact, fast, error-prone</li></ul><p>In practice, we always use analytic gradient, but check implementation with numerical gradient. This method is called a <strong>gradient check</strong>.</p><h3 id="3-Gradient-Descent-Strategies"><a href="#3-Gradient-Descent-Strategies" class="headerlink" title="3. Gradient Descent Strategies"></a>3. Gradient Descent Strategies</h3><h4 id="3-1-Gradient-Descent"><a href="#3-1-Gradient-Descent" class="headerlink" title="3.1 Gradient Descent"></a>3.1 Gradient Descent</h4><p>Iteratively step in the direction of the negative gradient (direction of local steepest descent).</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">w &#x3D; initialize_weights()for t in range(num_steps):dw &#x3D; compute_gradient(loss_fn, data, w)w -&#x3D; learning_rate * dw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>In this code block, there have some hyper-parameters:</p><ul><li>Weight initialization method</li><li>Number of steps</li><li>Learning rate</li></ul><h4 id="3-2-Stochastic-Gradient-Descent"><a href="#3-2-Stochastic-Gradient-Descent" class="headerlink" title="3.2 Stochastic Gradient Descent"></a>3.2 Stochastic Gradient Descent</h4><p>However, calculating all example sum is too expensive when \(N\) is large.</p><h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><ul><li><a href="https://web.eecs.umich.edu/~justincj/teaching/eecs498/WI2022/">Main Page</a></li><li><a href="">Video Page</a></li><li><a href="">Assignment Repo</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Vision </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES003：Basic scientific literacy</title>
      <link href="/posts/Basic-scientific-literacy.html"/>
      <url>/posts/Basic-scientific-literacy.html</url>
      
        <content type="html"><![CDATA[<h2 id="Week1-课程内容概览-建立领域视野"><a href="#Week1-课程内容概览-建立领域视野" class="headerlink" title="Week1: 课程内容概览 &amp; 建立领域视野"></a>Week1: 课程内容概览 &amp; 建立领域视野</h2><h3 id="课程动机"><a href="#课程动机" class="headerlink" title="课程动机"></a>课程动机</h3><p><strong>科研中常见情况</strong>：缺乏研究策略 \(\rightarrow\) 面临科研困难 \(\rightarrow\) 遭遇情绪低落</p><p><strong>课程内容</strong>：如何选题与设计方法 \(\rightarrow\) 如何实验与提升方法 \(\rightarrow\) 如何写作与宣传工作</p><p><strong>课程目标</strong>：知道如何在科研过程中自我提升科研能力，成为一个快乐的研究人员。</p><h3 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h3><p>传授科研流程，解释每一步的具体操作，配合案例加以说明。</p><ol><li><strong>初始化科研课题</strong>：建立领域视野 \(\rightarrow\) 选择科研课题 \(\rightarrow\) 设计技术方案</li><li><strong>迭代技术方案</strong>：基于技术方案设计实验 \(\leftrightarrow\) 基于实验结果提升方案</li><li><strong>撰写学术论文</strong>：写作规划 \(\rightarrow\) 故事梳理 \(\rightarrow\) 论文画图 \(\rightarrow\) 论文写作 \(\rightarrow\) 论文评审</li></ol><p>分享科学研究中的软技能，包括如何做报告和一些有用的科研习惯。</p><h3 id="怎么最好的受益"><a href="#怎么最好的受益" class="headerlink" title="怎么最好的受益"></a>怎么最好的受益</h3><ol><li>从本课程中学习科研流程与每个步骤的方法论</li><li>根据自己的经验思考并总结方法论</li><li>通过<strong>实践</strong>熟悉研究方法</li><li><strong>重要</strong>：总结<strong>你自己的</strong>研究方法</li></ol><h3 id="课程概览"><a href="#课程概览" class="headerlink" title="课程概览"></a>课程概览</h3><h4 id="第一部分：初始化科研课题"><a href="#第一部分：初始化科研课题" class="headerlink" title="第一部分：初始化科研课题"></a>第一部分：初始化科研课题</h4><h5 id="Step1：建立领域视野"><a href="#Step1：建立领域视野" class="headerlink" title="Step1：建立领域视野"></a>Step1：建立领域视野</h5><blockquote><p>什么是领域视野 ？</p></blockquote><p>“ 领域 ” 的定义：特定的科研方向，如 <code>3D reconstruction</code>, <code>Novel view synthesis</code>.</p><div class="markmap-container" style="height:150px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;领域视野&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;对&lt;strong&gt;技术演变&lt;/strong&gt;的视野&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;有哪些 milestone papers ？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;领域技术如何随着时间的推移而演变 ？&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;对&lt;strong&gt;重要问题的&lt;/strong&gt;视野&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;这个领域的终极目标是什么 ？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;该领域已经达到了什么水平 ？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;还有哪些重要的问题仍未被解决 ？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;现阶段的热点话题是什么 ？&quot;}]}]}"></svg></div><blockquote><p>为什么需要建立视野 ？</p></blockquote><p><strong>领域的视野</strong>为以下五件事奠定基础</p><div class="markmap-container" style="height:150px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;领域的视野奠定的基础&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;课题选择&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;方法设计&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;实验中迭代提升方法&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;故事梳理&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;论文写作&quot;}]}"></svg></div><p>做好以上六件事情成为该领域的专家。</p><blockquote><p>如何建立领域的视野 ？</p></blockquote><ol><li>确定领域的 <code>milestone papers</code></li><li>查找之前和之后的论文</li><li>阅读论文以了解这些论文解决的问题和<code>pipeline</code>，以及他们的技术见解</li><li>整理技术的演变轨迹 \(\rightarrow\) 跟踪和预测新技术</li><li>整理领域热点问题的演变 \(\rightarrow\) 跟踪和预测新问题</li></ol><p><strong>案例学习：多视角重建</strong></p><div class="markmap-container" style="height:200px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;&lt;strong&gt;多视角重建&lt;/strong&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;200?-2016, Colmap：Multi-view stereo&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;2018-2021, MVSNet：使用 3D CNN 在 cost volume 融合&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;2020-2023，NeRF：定义  global representation， 使用differentiable rendering融合&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;2023-2024，DUSt3R：将图像 tokenlize 后，使用 vit 融合&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;2023-2024，CAT3D：使用 Multi-view Diffusion Model 融合&quot;}]}"></svg></div><blockquote><p>如何识别 MileStone papers？</p></blockquote><ol><li><p>查找该领域被引用次数最多的论文并按照日期对它们进行排序。</p></li><li><p>寻求经验丰富的研究人员的建议。</p></li></ol><blockquote><p>怎么梳理技术发展脉络？</p></blockquote><p>首先，初始化一个时间轴，将论文列到时间轴、并阅读每篇论文，了解它解决的问题、pipeline和技术见解。</p><p>然后，确定哪些论文是 milestone paper、哪些论文是 follow-up，根据论文方法的创新度判断。</p><ul><li>Milestone paper 的技术范式</li><li>Follow-up papers 作出的改进</li></ul><p>最后，总结这些论文，构建思维导图，看看每年的热点问题是什么，并要求能够回答如下问题：</p><div class="markmap-container" style="height:110px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;总结该领域的发展&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;这个领域的终极目标是什么？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;该领域已经到达了什么水平？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;还有哪些重要的问题仍未被解决？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;现阶段的热点话题是什么？&quot;}]}"></svg></div><blockquote><p>如何有效阅读论文 ？</p></blockquote><p>可以借助<strong>论文解析树</strong>来解决这个问题，<strong>将阅读论文的过程转变为回答问题的过程</strong>。论文解析树的结构如下：</p><div class="markmap-container" style="height:200px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Abstract&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;What Task or Challege?&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Technical challenge for previous methods?&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Challenge的key insight/motivation?&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;介绍insight/motivation&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;介绍insight advantage&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;介绍technical contributions N&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;technical contribution N&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;介绍 technical contribution N&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;介绍 technical advantage&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;Experiment&quot;}]}"></svg></div><div class="markmap-container" style="height:200px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Introduction&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;What Task and application?&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Technical challenge for previous methods?&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Technical challenge N&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Previous method&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Failure cases (Limitation)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;Technical reason&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Our pipeline?&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;介绍key innovation/insight/motivation&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;contribution N&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;具体做法&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;讨论advantage/insight&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;cool demos/applications&quot;}]}"></svg></div><div class="markmap-container" style="height:200px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Method&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;Overview&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;具体的任务：输入和输出&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;方法：step1、step2、step3...&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Pipeline module 1&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Motivation&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;How to do？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Why work？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;techical advantage&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Pipeline module N&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;Motivation&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;How to do？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Why work？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;techical advantage&quot;}]}]}"></svg></div><div class="markmap-container" style="height:100px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Experiments&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;Comparison experiments&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Ablation experiments&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;论文的core contributions以及一些重要的components对论文方法performance的影响&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;列出每个pipeline module中design choices对论文方法performance的影响&quot;}]}]}"></svg></div><h5 id="Step2：选择科研课题"><a href="#Step2：选择科研课题" class="headerlink" title="Step2：选择科研课题"></a>Step2：选择科研课题</h5><blockquote><p>如何选择课题？</p></blockquote><p>选择课题需要确定如下两件事情：</p><ol><li>确定 <code>Project setting</code>，输入和输出</li><li>确定想解决的 <code>Failure case</code> 及其背后的技术挑战</li></ol><blockquote><p>为什么课题选择非常重要 ？</p></blockquote><p>一个好的课题将使科研变得容易很多。</p><div class="markmap-container" style="height:150px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;什么是好的课题？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2],&quot;index&quot;:1},&quot;v&quot;:&quot;1. 发展空间大、竞争程度小&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3],&quot;index&quot;:2},&quot;v&quot;:&quot;2. 任务难度与个人能力相匹配&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;任务太难，可能导致无法完成&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;任务简单，可能没法锻炼技术能力&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[5,6],&quot;index&quot;:3},&quot;v&quot;:&quot;3. 该课题的影响力&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;考虑该项目学术影响程度&quot;}]}]}"></svg></div><blockquote><p>如何找到好的课题 ？</p></blockquote><div class="markmap-container" style="height:220px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;寻找好课题的四个步骤&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2],&quot;index&quot;:1},&quot;v&quot;:&quot;1. 建立领域视野&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;整理milestone papers和技术范式&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;了解它们是如何随着时间演变的&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5],&quot;index&quot;:2},&quot;v&quot;:&quot;2. 列出领域内的课题&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;列出领域的重要问题&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;判断哪个问题是当前时间点应该去解决的&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[7,8],&quot;index&quot;:3},&quot;v&quot;:&quot;3. 判断哪些课题是好课题&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;评估课题的竞争程度和发展空间&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;考虑任务的难度与个人能力相匹配&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[10,11],&quot;index&quot;:4},&quot;v&quot;:&quot;4. 在选题上 Aim High&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;考虑任务的影响力&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;技术风险性大的课题往往有更高的受益&quot;}]}]}"></svg></div><p>Aim high: 努力完成一个达到你能力极限的科研课题。</p><h5 id="Step3：设计技术方案"><a href="#Step3：设计技术方案" class="headerlink" title="Step3：设计技术方案"></a>Step3：设计技术方案</h5><blockquote><p>什么是方法设计？</p></blockquote><p>在选定课题后，需要设计一一种新颖的<code>pipeline</code>来达到<code>SOTA performance</code>。</p><blockquote><p>为什么要有方法设计的系统性思路？</p></blockquote><ul><li>一个清晰的方法设计思路能够更有效地解决问题问题并达到<code>SOTA</code></li><li>提出的方法更有动机，同时使得论文的故事更吸引人</li><li>保证了方法的技术创新性，以免审稿人说它没<code>novelty</code></li><li>同时，该系统性思路可以有效提升对技术的<code>insights</code></li></ul><blockquote><p>如何设计方法？</p></blockquote><ol><li><strong>分析原因</strong>： 遵从第一性原理，分析为什么当前的<code>SOTA</code>效果不够好。</li><li><strong>设计方法</strong>：根据分析的原因，设计一种能达到<code>SOTA</code>的方法。</li><li><strong>判断合理性</strong>：判断提出的技术方法是否合理。</li><li><strong>改进方法</strong>：通过读论文、讨论和做实验改进技术方法。</li></ol><blockquote><p>设计方法的<strong>三个要点</strong></p></blockquote><ul><li>不只是要<code>Work</code>，还要保证论文方法的<font color="red">技术创新性</font>。</li><li>争取在<code>Pipeline</code>层面设计解法。</li><li>要判断论文方法是否有足够技术贡献，是否有新的知识、新的认识、新的观点。</li></ul><h4 id="第二部分：迭代技术方案"><a href="#第二部分：迭代技术方案" class="headerlink" title="第二部分：迭代技术方案"></a>第二部分：迭代技术方案</h4><h5 id="Part1-基于技术方案设计实验"><a href="#Part1-基于技术方案设计实验" class="headerlink" title="Part1: 基于技术方案设计实验"></a>Part1: 基于技术方案设计实验</h5><blockquote><p>实验设计是什么？</p></blockquote><p>规划要做哪些实验，实现并提升<code>Technical idea</code>，达到<code>SOTA</code>指标。</p><blockquote><p>实验设计的两个好处</p></blockquote><ul><li><strong>让研究变得更简单</strong>：想清楚实验的目的，明确科学研究的方法。</li><li><strong>让实验更简单</strong>：降低实验难度，提高实验效率。</li></ul><blockquote><p>如何设计实验 ？</p></blockquote><p><strong>核心原则：减少实验中包含的探索点的数量。</strong></p><ul><li>如何减少 <code>exploration points</code> 的数量<ul><li>分解 <code>pipeline</code>：将 <code>idea</code> 分解为不同组件，从可控的<code>idea</code>开始，不断添加探索性和创新性的框架或模块。</li><li>分解实验设置：从一个简答的 <code>setting</code> 开始探索，然后逐渐增加难度，之后进入到真正的 <code>setting</code>。</li></ul></li></ul><p><strong>同时，还应该考虑 <code>exploration points</code> 的重要性，进行实验优先级排序。</strong></p><h5 id="Part2-基于实验结果提升方案"><a href="#Part2-基于实验结果提升方案" class="headerlink" title="Part2: 基于实验结果提升方案"></a>Part2: 基于实验结果提升方案</h5><blockquote><p>为什么需要改进方法 ?</p></blockquote><p><strong>因为初始提出的方法通常会不 Work</strong></p><p><strong>理想情况</strong>：提出一个 idea \(\rightarrow\) 进行实验 \(\rightarrow\) <font color=green>Good results</font></p><p><strong>实际情况</strong>：提出一个 idea \(\rightarrow\) 进行实验 \(\rightarrow\) <font color=red>Not working</font></p><blockquote><p>如何改进方法 ?</p></blockquote><p><strong>可以把改进方法的过程当做 SGD 优化过程。</strong></p><img src="https://github.com/TiredAce/pictures/blob/main/img/research_SGD.png?raw=true" width=700/><p>具体改进方法的思路：</p><img src="https://github.com/TiredAce/pictures/blob/main/img/improve_idea.png?raw=true" width=700/><h4 id="第三部分：论文写作"><a href="#第三部分：论文写作" class="headerlink" title="第三部分：论文写作"></a>第三部分：论文写作</h4><h5 id="Step1-写作规划"><a href="#Step1-写作规划" class="headerlink" title="Step1: 写作规划"></a>Step1: 写作规划</h5><ol><li>画一个清楚的<code>pipeline figure</code>的草图（ 理清楚方法的流程步骤），梳理论文<code>story</code>，写一版<code> introduction</code>的初稿。</li><li>列出要做的<code>comparison experiments</code>和<code>ablation studies</code>，并开始做起来。</li><li>写<code>method</code>，同时做实验。</li><li>改<code>introduction</code>和<code>method</code>，同时做实验。</li><li>实验做差不多以后，写<code>experiment</code>。</li><li>写<code>related work</code>。</li><li><code>Review</code>论文，改论文的<code>introduction</code>、<code>method</code>和<code>experiment</code>。</li><li>写<code>abstract</code>，取论文名字。</li><li>反复<code>review</code>论文，改论文。</li></ol><blockquote><p>为什么要规划写作 ？</p></blockquote><ul><li>大幅度<strong>提高投稿率！！</strong></li><li>让自己做论文更轻松，<strong>避免最后几天熬夜</strong>。</li></ul><h5 id="Step2-故事梳理"><a href="#Step2-故事梳理" class="headerlink" title="Step2: 故事梳理"></a>Step2: 故事梳理</h5><blockquote><p>怎么梳理论文故事？</p></blockquote><p>首先，整理论文方法流程，给论文画一个<code>pipeline figure</code>的草图，帮助自己直观地看清论文方法：</p><ul><li>按照 “ 输入 \(\rightarrow\) 模块1 \(\rightarrow\) 中间输出1 \(\rightarrow\) 模块2 \(\rightarrow … \ \rightarrow\) 模块N \(\rightarrow\) 输出 ”，用文字描述 <code>pipeline</code>。需要清楚地描述流程。</li><li>选择流程图的布局并绘制简单的流程图。</li></ul><p>第二，按序回答以下问题，</p><ol><li><code>pipeline</code>有哪些贡献（ 提出新任务、确定新的技术挑战、提出新的技术贡献 ）?</li><li>贡献有哪些好处 ？ 它们解决了哪些技术挑战 ?</li><li>论文带来了哪些新的<code>insights</code> ?</li><li>如何通过介绍以往的方法引入关注的技术挑战和新的<code>insights</code> ?</li></ol><p>第三，概述论文故事，</p><ol><li>介绍论文的任务。</li><li>通过讨论以前的方法来引入解决的技术挑战。</li><li>为了应对这一技术挑战，提出 XX 贡献。</li><li>贡献有哪些技术优势，有哪些新的<code>insights</code> ?</li></ol><h5 id="Step3-论文画图"><a href="#Step3-论文画图" class="headerlink" title="Step3: 论文画图"></a>Step3: 论文画图</h5><div class="markmap-container" style="height:100px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;论文中的图片&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;pipeline图&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;teaser图&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;定量结果&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;定性结果&quot;}]}"></svg></div><p>画好看的图的目的：<font color=green>提高中稿率</font></p><blockquote><p>绘制 pipeline 图的步骤流程</p></blockquote><ul><li>按照 “ 输入 \(\rightarrow\) 模块1 \(\rightarrow\) 中间输出1 \(\rightarrow\) 模块2 \(\rightarrow … \ \rightarrow\) 模块N \(\rightarrow\) 输出 ”，用文字描述 <code>pipeline</code>。需要清楚地描述流程。</li><li>选择流程图的布局并绘制简单的流程图。</li><li>可视化 “ 输入 ”、“模块”、“中间输出” 和 “输出” 等元素。</li><li>给流程图涂上颜色。</li><li>优化流程图布局，保证简洁。避免过多的空白区域和大大空白区域。</li></ul><p>好看的线条、框图、元素可视化、配色非常重要。</p><h5 id="Step4-论文写作"><a href="#Step4-论文写作" class="headerlink" title="Step4: 论文写作"></a>Step4: 论文写作</h5><blockquote><p>写 method 的步骤</p></blockquote><ol><li>画一个 <code>pipeline figure</code> 的草图。</li><li>梳理 <code>Method section</code>，确定各个<code>subsection</code>将涵盖哪个方法模块。</li><li>分别写各个<code>subsection</code>。每个<code>subsection</code>包括三个部分：模块的具体设计、模块的 motivation、模块的技术优势。<ul><li>首先写清楚模块的具体设计：给定 xx 输入，第一步 xx，第二步 xx，第三步 xx，最终得到 xx 输出。</li><li>然后模块的 <code>motivation</code>、技术优势。</li></ul></li></ol><h5 id="Step5-论文评审"><a href="#Step5-论文评审" class="headerlink" title="Step5: 论文评审"></a>Step5: 论文评审</h5><blockquote><p>评审论文时要做什么 ?</p></blockquote><p><strong>确定审稿人可能指出的潜在问题。</strong></p><blockquote><p>为什么要自我评审 ?</p></blockquote><p><strong>以提高论文的中稿率。</strong></p><blockquote><p>如何自我评审论文 ?</p></blockquote><p>通过如下 checklist 检查论文中是否还存在漏洞。</p><div class="markmap-container" style="height:350px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;自我评审checklist&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;技术贡献是否足够&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;想解决的failure cases很常见&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;提出的技术已经被well-explored，该技术带来的performance improvement是可预见的&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;论文写作是否清楚&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;论文 Introduction 是否清楚描述论文贡献&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;论文 pipeline figure 是否清楚描述 pipeline 与技术贡献&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;缺少技术细节，不可复现&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;每个方法模块是否都写了 motivation&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;实验效果是否足够好&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;是否比之前方法好很多&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;实验效果是否让人impressive&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;实验测试是否充分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;缺少 ablation studies&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;缺少重要的 baselines、缺少重要的 evaluation metric&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;数据太简单，无法证明方法是否真的 work&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;方法设计是否合理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;实验的 setting 不实际&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;方法存在技术缺陷，看起来不合理&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;方法模块的鲁棒性：是否需要在每个场景上调超参&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;新的方法设计在带来benefit的同时，引入了更强的limitation，导致新方法的收益为负。&quot;}]}]}"></svg></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://pengsida.net/games003/">GAMES003: 图形视觉科研基本素养</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Vision </tag>
            
            <tag> Research </tag>
            
            <tag> Graphic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Awesome Leetcode</title>
      <link href="/posts/Algorithm-Questionnaire.html"/>
      <url>/posts/Algorithm-Questionnaire.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Notice：本题单属于<strong>进阶</strong>题单，其中选取的题目都属于<font color=orange> Medium </font>和<font color=Red> Hard </font>难度。<a href="https://programmercarl.com/">0 基础 Leetcode 题单</a></p></blockquote><h2 id="1-滑动窗口与双指针"><a href="#1-滑动窗口与双指针" class="headerlink" title="1. 滑动窗口与双指针"></a>1. 滑动窗口与双指针</h2><h3 id="1-1-定长滑动分类总览"><a href="#1-1-定长滑动分类总览" class="headerlink" title="1.1 定长滑动分类总览"></a>1.1 定长滑动分类总览</h3><div class="markmap-container" style="height:120px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;滑动窗口与双指针&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;定长滑动窗口&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;不定长滑动窗口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;求最长/最大&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;求最短/最小&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;求子数组个数&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;单序列双指针&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;双序列双指针&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;三指针&quot;}]}"></svg></div><h3 id="1-2-定长滑动窗口精选"><a href="#1-2-定长滑动窗口精选" class="headerlink" title="1.2 定长滑动窗口精选"></a>1.2 定长滑动窗口精选</h3><ul><li><a href="https://leetcode.cn/problems/count-complete-substrings/description/"> 2953. Count Complete Substrings - <font color=Red>Hard(2449)</font></a></li><li><a href="https://leetcode.cn/problems/contains-duplicate-iii/description/"> 220. Contains Duplicate III - <font color=Red>Hard</font></a></li></ul><h3 id="1-3-不定长滑动窗口精选"><a href="#1-3-不定长滑动窗口精选" class="headerlink" title="1.3 不定长滑动窗口精选"></a>1.3 不定长滑动窗口精选</h3><ul><li><a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/description/">2779. Maximum Beauty of an Array After Applying Operation - <font color=orange>Medium(1638)</font></a></li><li><a href="https://leetcode.cn/problems/length-of-the-longest-valid-substring/description/">2781. Length of the Longest Valid Substring - <font color=Red>Hard(2204)</font></a></li><li><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/description/">2009. Minimum Number of Operations to Make Array Continuous - <font color=Red>Hard(2084)</font></a></li><li><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/description/">1234. Replace the Substring for Balanced String - <font color=orange>Medium(1878)</font></a></li><li><a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/description/">2875. Minimum Size Subarray in Infinite Array - <font color=orange>Medium(1914)</font></a></li><li><a href="https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/description/">3134. Find the Median of the Uniqueness Array - <font color=Red>Hard(2451)</font></a></li><li><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit - <font color=orange>Medium(1672)</font></a></li></ul><h3 id="1-4-单序列双指针"><a href="#1-4-单序列双指针" class="headerlink" title="1.4 单序列双指针"></a>1.4 单序列双指针</h3><ul><li><a href="https://leetcode.cn/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/description/">1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers - <font color=orange>Medium(1594)</a></li></ul><h2 id="2-二分算法"><a href="#2-二分算法" class="headerlink" title="2. 二分算法"></a>2. 二分算法</h2><h3 id="2-1-二分算法分类总览"><a href="#2-1-二分算法分类总览" class="headerlink" title="2.1 二分算法分类总览"></a>2.1 二分算法分类总览</h3><div class="markmap-container" style="height:140px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;二分算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;二分查找&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;二分答案&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;求最大&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;求最小&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;最大化最小值&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;最小化最大值&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;二分间接值&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;第 K 小/大&quot;}]}"></svg></div><h3 id="2-2-二分查找精选"><a href="#2-2-二分查找精选" class="headerlink" title="2.2 二分查找精选"></a>2.2 二分查找精选</h3><ul><li><a href="https://leetcode.cn/problems/minimum-array-length-after-pair-removals/description/">2856. Minimum Array Length After Pair Removals - <font color=orange>Medium(1750)</font></a></li></ul><h3 id="2-3-二分答案精选"><a href="#2-3-二分答案精选" class="headerlink" title="2.3 二分答案精选"></a>2.3 二分答案精选</h3><h2 id="3-单调栈"><a href="#3-单调栈" class="headerlink" title="3. 单调栈"></a>3. 单调栈</h2><h2 id="4-网格图"><a href="#4-网格图" class="headerlink" title="4. 网格图"></a>4. 网格图</h2><h2 id="5-位运算"><a href="#5-位运算" class="headerlink" title="5. 位运算"></a>5. 位运算</h2><h2 id="6-图论算法"><a href="#6-图论算法" class="headerlink" title="6. 图论算法"></a>6. 图论算法</h2><h2 id="7-动态规划"><a href="#7-动态规划" class="headerlink" title="7. 动态规划"></a>7. 动态规划</h2><h3 id="7-1-动态规划总览"><a href="#7-1-动态规划总览" class="headerlink" title="7.1 动态规划总览"></a>7.1 动态规划总览</h3><div class="markmap-container" style="height:250px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;动态规划&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;网格图DP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;背包问题&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;线性DP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;树形DP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;状态机DP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;划分DP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;区间DP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;状态压缩DP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;数位DP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;数据结构优化DP&quot;}]}"></svg></div><ul><li><a href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/description/">3144. Minimum Substring Partition of Equal Character Frequency - <font color=orange>Medium(1917)</font></a></li></ul><h2 id="8-数据结构"><a href="#8-数据结构" class="headerlink" title="8. 数据结构"></a>8. 数据结构</h2><h2 id="9-数学"><a href="#9-数学" class="headerlink" title="9. 数学"></a>9. 数学</h2><h2 id="10-贪心算法"><a href="#10-贪心算法" class="headerlink" title="10. 贪心算法"></a>10. 贪心算法</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Network Basics</title>
      <link href="/posts/Interview-Computer-Network.html"/>
      <url>/posts/Interview-Computer-Network.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机网络体系结构"><a href="#1-计算机网络体系结构" class="headerlink" title="1. 计算机网络体系结构"></a>1. 计算机网络体系结构</h2><h3 id="1-1-计算机网络的主要功能"><a href="#1-1-计算机网络的主要功能" class="headerlink" title="1.1 计算机网络的主要功能"></a>1.1 计算机网络的主要功能</h3><ol><li><strong>硬件资源共享</strong><ul><li>可以在全网范围内提供对处理资源、存储资源、输入输出资源等昂贵设备的共享，使用户节省投资，也便于集中管理和均衡分担负荷。</li></ul></li><li><strong>软件资源共享</strong><ul><li>允许互联网上的用户远程访问各类大弄数据库，可以得到网络文件传送服务、远地进程管理服务 和远程文件访问服务，从而避免软件研制上的重复劳动以及数据资源的重复存贮，也便于集中管理。</li></ul></li><li><strong>用户间信息交换</strong><ul><li>计算机网络为分布在各地的用户提供了强有力的通信手段。用户可以通过计算机网络传送电子邮件、发布新闻消息和进行电子商务活动。</li></ul></li><li><strong>分布式处理</strong><ul><li>当计算机网络中某个计算机系统负荷过重时，可以将其处理的某个复杂任务分配给网络中的其他计算机系统，从而利用空闲计算机资源以提高整个系统的利用率。</li></ul></li></ol><h3 id="1-2-主机间的通信方式"><a href="#1-2-主机间的通信方式" class="headerlink" title="1.2 主机间的通信方式"></a>1.2 主机间的通信方式</h3><ol><li><strong>客户-服务器（C&#x2F;S）</strong><ul><li>客户是服务请求方，服务器是服务的提供方。</li></ul></li><li><strong>对等（P2P）</strong><ul><li>不区分客户和服务器。</li></ul></li></ol><h3 id="1-3-电路交换，报文交换和分组交换的区别"><a href="#1-3-电路交换，报文交换和分组交换的区别" class="headerlink" title="1.3 电路交换，报文交换和分组交换的区别"></a>1.3 电路交换，报文交换和分组交换的区别</h3><p>电路交换、报文交换和分组交换是三种不同的通信方式，用于在网络中传输数据。它们在数据传输的方式、效率和适用场景上有明显的区别。</p><ol><li><p><strong>电路交换</strong></p><ul><li>电路交换是一种传统的通信方式，主要用于电话网络。包括建立连接、传输数据和断开连接三个阶段。一旦建立了这条电路，通信双方可以独占这条路径进行数据传输，直到通信结束。</li><li>特点：<ul><li><strong>专用通道</strong>：通信开始前需要建立一条固定的通道，通道独占，直到通信结束。</li><li><strong>实时性强</strong>：数据传输是连续的，适合实时通信，如语音通话。</li><li><strong>资源利用率低</strong>：即使在通信过程中没有数据传输，这条通道仍然被占用，导致资源利用效率较低。</li></ul></li></ul></li><li><p><strong>报文交换</strong></p><ul><li>将整个报文转发到相邻结点，全部存储下来，查找转发表，转发到下一个结点。是<strong>存储-转发</strong>类型的网络。</li><li>特点：<ul><li><strong>无专用通道</strong>：不需要在发送端和接收端之间建立专用通道。</li><li><strong>灵活性高</strong>：数据可以根据网络状况选择不同的路径传输。</li><li><strong>延时较大</strong>：因为中间节点需要存储和转发整个报文，可能导致较大的传输延时。</li></ul></li></ul></li><li><p>分组交换</p><ul><li>分组交换是将数据分割成较小的分组（数据包）进行传输，每个分组包含目的地址等控制信息。每个分组独立在网络中传输，可能经过不同的路径到达目的地。到达目的地后，分组会被重新组装成原始数据。</li><li>特点：<ul><li><strong>高效利用网络资源</strong>：分组交换允许多个用户共享网络带宽，数据包可以在不同路径上进行传输，提高了网络资源的利用率。</li><li><strong>鲁棒性强</strong>：如果某条路径发生故障，数据包可以通过其他路径传输，提高了传输的可靠性。</li><li><strong>适用于突发性流量</strong>：分组交换非常适合互联网等网络流量较为突发的场景，如网页浏览和数据传输。</li></ul></li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures/img/20240825140030.png" alt="图1 三种通信方式" width="500"/><h3 id="1-4-计算机网络的主要性能指标"><a href="#1-4-计算机网络的主要性能指标" class="headerlink" title="1.4 计算机网络的主要性能指标"></a>1.4 计算机网络的主要性能指标</h3><ol><li><p><strong>宽带（Bandwidth）</strong></p><ul><li>原本表示通信线路允许通过的信号频带范围。在计算机网络中，表示网络的通信线路所能传送数据的能力，是能传送的“最高数据率”的同义词，单位是比特每秒（b&#x2F;s）。</li></ul></li><li><p><strong>时延（Delay）</strong></p><ul><li><strong>排队时延</strong>：分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</li><li><strong>处理时延</strong>：主机或者路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</li><li><strong>传输时延</strong>：传输时延又称为发送时延，表示结点将分组所有比特推向链路所需要的时间。</li><li><strong>传播时延</strong>：电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</li></ul></li></ol><p>$$<br>\text{总时延} &#x3D; \text{排队时延} + \text{处理时延} + \text{传输时延} + \text{传播时延}<br>$$</p><ol start="3"><li><strong>时延宽带积</strong></li></ol><ul><li>指的是发送端发送的第一个比特即将到达终点时，发送端已经发送了多少个比特，因此又称以比特为单位的链路长度，即 \(\text{时延宽带积}&#x3D;\text{传播时延} \times \text{信道带宽}\)。</li></ul><h3 id="1-5-ISO-OSI-参考模型和TCP-IP-模型"><a href="#1-5-ISO-OSI-参考模型和TCP-IP-模型" class="headerlink" title="1.5 ISO&#x2F;OSI 参考模型和TCP&#x2F;IP 模型"></a>1.5 ISO&#x2F;OSI 参考模型和TCP&#x2F;IP 模型</h3><h4 id="TCP-IP-网络模型总览"><a href="#TCP-IP-网络模型总览" class="headerlink" title="TCP&#x2F;IP 网络模型总览"></a>TCP&#x2F;IP 网络模型总览</h4><div class="markmap-container" style="height:250px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;TCP/IP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;应用层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;HTTP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Telnet&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;FTP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;TFTP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;DNS&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;SMTP&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;传输层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;四层交换机、四层路由器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;TCP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;UDP&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;网络层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;路由器、三层交换机&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;IP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;ICMP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;RIP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;IGMP&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;数据链路层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;网卡、网桥、以太网交换机&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;ARP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;RARP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;IEEE80 2.3&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;PPP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;CSMA/CD&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;物理层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;明线、电缆、光纤、中继器等&quot;}]}]}"></svg></div><p>同一台设备的的进程间通信方式有很多，比如管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，又由于设备是多样的，所以要兼容各种各样的设备，就协商出一套<strong>通用的网络协议</strong>。</p><h4 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h4><p>最上层的，就是直接能接触到的应用层（OSI：应用层+ 表示层+ 会话层），设备是使用的应用软件都是在应用层实现。当两个设备需要通信时，应用就把应用数据传给下一层，即传输层。所以，应用层只需要专注于为用户提供应用功能，比如<code>HTTP</code>、<code>FTP</code>、<code>DNS</code>、<code>SMTP</code>等。</p><h4 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h4><p>应用层的数据包会传给传输层，<strong>传输层</strong>是为应用层提供网络支持的。在传输层会有两个传输协议，分别是<code>TCP</code>和<code>UDP</code>。</p><p><code>TCP</code>全称叫传输控制协议（Transmission Control Protocol），大部分应用使用的正是<code>TCP</code>传输层协议，比如<code>HTTP</code>协议。<code>TCP</code>相比<code>UDP</code>多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠的传输给对方。</p><p><code>UDP</code>与<code>TCP</code>相比就简单许多，该协议只负责转发数据包，不保证数据能够送到接收方，因此其实时性相对更好，传输的效率也更高。</p><p>应用需要传输的数据可能会非常大，因此如果在传输层直接传输就不好控制，因此当传输层的数据包大小超过MSS（TCP 最大报文段长度），就要将数据分段，即使某个分段丢失或损坏，也只需要重新发送这一分块，而不是重新发送整个数据包。其中在<code>TCP</code>协议中，称之为TCP 端。</p><p>当设备需要接收数据时，传输层要负责把数据包传给应用，此时就需要使用<strong>端口</strong>来将应用区分开来。常见的端口比如<code>80</code>端口通常是Web 服务器用的，<code>22</code>端口通常是远程登录服务器用的。浏览器中每个标签栏都是一个独立的进程，操作系统会给这些进程分配临时的端口号。</p><h4 id="网络层（Internet-Layer）"><a href="#网络层（Internet-Layer）" class="headerlink" title="网络层（Internet Layer）"></a>网络层（Internet Layer）</h4><p>实际场景中的网络错综复杂。如果一个设备数据要传送给另一个设备，就需要在各种各样的结点中选择，然而，传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就会违背设计的原则，即传输层只负责服务号应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际传输功能为其下一层，也就是<strong>网络层</strong>。</p><p>网络层最常使用的协议是 IP 协议（Internet Protocal），该协议将传输层的报文作为数据部分，再加上IP包头组装成 IP 报文，如果 IP 报文长度超过 MTU（ 以太网一般为 1500 字节）就会<strong>再次分片</strong>，得到一个即将发送到网络的 IP 报文。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures/img/12.jpg" alt="图2 报文流动过程" width="500"/><p>网络层一般使用 IP 地址给设备进行编号，对于 IPv4 协议，IP 地址共 32 位，分为四段，每段 8 位。每个 IP 地址由<strong>网络号</strong>和<strong>主机号</strong>组成。</p><ul><li><strong>网络号</strong>：负责标识该 IP 地址属于哪个<strong>子网</strong>。</li><li><strong>主机号</strong>：负责标识同一个子网下的<strong>不同主机</strong>。</li></ul><p>那么哪几位为网络号？哪几位为主机号？此时就需要使用<strong>子网掩码</strong>进行计算。计算方式为将 IP 地址与子网掩码进行按位与运算，就可以得到网络号；子网掩码取反后与 IP 地址进行按位与运算，就可以得到主机号。</p><p>IP 地址除了寻址，还有一个功能就是路由。路由器在寻址的过程中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络去。</p><p><strong>总结，IP 协议的寻址功能就是告诉报文下一个目的地该朝哪个方向走，路由则是根据下一个目的地选择路径。</strong></p><h4 id="网络接口层（Link-Layer）"><a href="#网络接口层（Link-Layer）" class="headerlink" title="网络接口层（Link Layer）"></a>网络接口层（Link Layer）</h4><p>有了 IP 地址后，接下来就要交给数据链路层（数据链路层 + 物理层），在 IP 报文的加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。<br>为何有了 IP 地址，还需要加入 MAC 地址，这是因为以太网其实是一种局域网，把附近的设备连接起来，从而进行通信的技术，在判断网络包是否到达目的地时，必须采用相匹配的方式才能在以太网中将包发往目的地，因此需要使用 MAC 头部中的 MAC 地址，该地址可以通过<code>ARP</code>协议获取对方的 MAC 地址。</p><p><strong>总结，数据链路层主要是为网络层提供链路级别的数据传输服务，在底层网络上发送数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备</strong>。</p><hr><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="图3 不同层级的数据封装" width="500"/><p>数据链路层的传输单位是帧（frame），网络层的传输单位是包（packet），运输层的传输单位是段（segment），应用层的传输单位则是消息或报文（message），所有的名词可以统称为数据包。</p><h2 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2. 应用层"></a>2. 应用层</h2><h3 id="2-1-应用层总览"><a href="#2-1-应用层总览" class="headerlink" title="2.1 应用层总览"></a>2.1 应用层总览</h3><div class="markmap-container" style="height:400px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;应用层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;网络应用模型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;C/S模型：区分处理请求的服务器和发出请求的客户机&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;P2P模型：每台机器既是服务器又是客户机&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;域名解析（DNS）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;作用：把主机名转化为IP地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;协议与端口：运行在UDP之上，使用53端口&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;服务器分类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;根域名服务器：知道所有顶级域名服务器的IP地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;顶级域名服务器：负责管理在其服务器注册的所有二级域名&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;授权域名服务器：能够将其管辖的主机名转换为该主机的IP地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;本地域名服务器：本地网络提供商负责的域名服务器&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;查询方式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;递归查询：由查询服务器发起下一次的查询&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;递归与迭代：出了第一个查询外，其余均有本地域名服务器向外查询&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;文件传输协议（FTP）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;作用：允许用户在因特网上存取文件&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;协议与端口：运行在TCP上，控制链接为21号端口，数据链接20号端口&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;电子邮件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;STMP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;作用：向邮件服务器主动发送电子邮件&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;协议与端口：运行在TCP上，使用25号端口&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;POP3&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;作用：向邮件服务器要求接收电子邮件&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;协议与端口：运行在TCP上，使用110号端口&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;万维网&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;统一资源定位符（URL）：负责标识万维网上的各种文档&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;超文本传输协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;作用：在万维网上能够可靠地交换文件&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;协议与端口：运行在TCP之上，使用80号端口&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;超文本标记语言：文档结构标记语言，使用约定的标记对页面上的各种信息进行描述&quot;}]}]}"></svg></div><h3 id="2-2-DNS-域名解析协议"><a href="#2-2-DNS-域名解析协议" class="headerlink" title="2.2 DNS 域名解析协议"></a>2.2 DNS 域名解析协议</h3><p>域名解析就是把域名映射成 IP 地址或把 IP 地址映射成域名的过程。前者为正向解析，后者称为反向解析。当客户端需要域名解析时，通过本机 DNS 客户端构造一个 DNS 请求报文，以 <code>UDP</code> 数据报方式发送到本地域名服务器。解析的方式有两种：</p><ul><li>递归查询</li><li>递归与迭代相结合的查询</li></ul><p>其中递归与迭代相结合的查询方式更为常见，其工作流程如下：</p><ol><li>客户端首先会发送一个 DNS 请求给本地域名服务器，目的是让本地域名服务器替本地主机查询服务器的 IP 地址。</li><li>本地域名服务器收到客户端的请求后，首先会在缓存中寻找时候有对应的 <code>&lt; 域名, IP&gt;</code>，如果有则直接返回 IP 地址；如果没有，本地 DNS 会去访问其根域名服务器。</li><li>根域名服务器并不会直接替其递归查询目标 IP 地址，而是查询顶级域名服务器的 IP 地址并返回顶级域名服务器的 IP 地址给本地域名服务器。本地域名服务器根据收到的顶级域名服务器 IP 地址，接着发送询问请求。</li><li>顶级域名服务器也并不会替其递归查询目标 IP 地址，而是返回对应的权威域名服务器的 IP 地址给本地域名服务器。本地服务器接着询问权威服务器。</li><li>权威服务器知道目标服务器的 IP 地址，因此返回给本地域名服务器目标服务器的 IP 地址。</li><li>本地域名服务器再将目标服务器的 IP 地址返回给客户端。至此，客户端完成 DNS 解析。</li></ol><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg" alt="图4 DNS 解析过程" width="600"/><h3 id="2-3-FTP-文件传输协议"><a href="#2-3-FTP-文件传输协议" class="headerlink" title="2.3 FTP 文件传输协议"></a>2.3 FTP 文件传输协议</h3><p>文件传输协议（File Transfer Protocol，FTP）是因特网上使用的最广泛的文件传输协议。FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限，适用于异构网络中任意计算机之间传送文件。FTP 提供以下功能：</p><ol><li>提供不同种类主机系统之间的文本传输能力。</li><li>以用户权限管理的方式提供用户对远程 FTP 服务器上的文件管理能力。</li><li>以匿名 FTP 的方式提供公用文件共享的能力。</li></ol><p>FTP 采用 C&#x2F;S 工作方式，使用<code>TCP</code>进行可靠传输服务。一个 FTP 服务器进程可以同时为多个客户进程提供服务。FTP 的服务器进程分为两大部分组成：一个主进程，负责接收新的请求；另外有若干从属进程，负责处理单个请求。工作步骤如下：</p><ol><li>服务器打开21 号端口，使客户进程能够连接上。</li><li>等待客户进程发连接请求。</li><li>启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止。</li><li>回到等待状态，继续接收其他客户进程的请求。</li></ol><h3 id="2-4-SMTP-简单邮件传输协议"><a href="#2-4-SMTP-简单邮件传输协议" class="headerlink" title="2.4 SMTP 简单邮件传输协议"></a>2.4 SMTP 简单邮件传输协议</h3><p>简单邮件传输协议（Simple Mail Transfer Protocol, SMTP） 是一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的 SMTP 进程交换信息。由于 SMTP 使用 C&#x2F;S 方式，因此负责发送邮件的 SMTP 进程就是SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。SMTP 用的是<code>TCP</code>连接，端口号为25 。</p><h3 id="2-5-POP3-邮局协议"><a href="#2-5-POP3-邮局协议" class="headerlink" title="2.5 POP3 邮局协议"></a>2.5 POP3 邮局协议</h3><p>邮局协议（Post Office Protocol, POP） 是一个非常简单但功能有限的邮件读取协议，POP3 采用的是拉（Pull） 的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，POP 也使用 C&#x2F;S 的工作方式，在传输层使用<code>TCP</code>, 端口号为110 。</p><p>随着万维网的流行，目前出现了很多基于万维网的电子邮件，如<code>Hotmail</code>、<code>Gmail</code>等。这种电子 邮件的特点是，用户浏览器与<code>Hotmail</code>或<code>Gmail</code>的邮件服务器之间的邮件发送或接收使用的是 <code>HTTP</code>, 而仅在不同邮件服务器之间传送邮件时才使用<code>SMTP</code>。</p><h3 id="2-6-HTTP-超文本传输协议"><a href="#2-6-HTTP-超文本传输协议" class="headerlink" title="2.6 HTTP 超文本传输协议"></a>2.6 HTTP 超文本传输协议</h3><p>HTTP 定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。</p><blockquote><p>那么当浏览器键入网址后，到网页显示，期间发生了什么呢？</p></blockquote><h4 id="HTTP-：解析URL"><a href="#HTTP-：解析URL" class="headerlink" title="HTTP ：解析URL"></a>HTTP ：解析URL</h4><p>首先浏览器做的第一步工作就是将网址进行解析，只有解析完了网址，才知道请求信息需要发送到哪个服务器。一个URL 通常由这么几个部分构成<code>http://Web服务器地址/目录名/文件名</code>，其中<code>目录名/文件名</code>是可以被省略掉的，没有路径名时，就代表访问根目录下<strong>默认文件</strong>。根据 URL 拆分得到如下几个部分：</p><ul><li>数据协议：URL开头的部分，即<code>http:</code></li><li>服务器地址：&#x2F;&#x2F; 后面的字符串标识服务器地址</li><li>数据源路径名：服务器地址后跟着的路径名</li></ul><p>对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，根据这些信息生成 HTTP 请求消息。</p><h4 id="DNS-：查询IP-地址"><a href="#DNS-：查询IP-地址" class="headerlink" title="DNS ：查询IP 地址"></a>DNS ：查询IP 地址</h4><p>再发送 HTTP 请求信息之前，还有一项工作，即<strong>查询服务器域名对应的IP地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。因此，DNS 服务器就派上用场了。当然，并不是每次都需要这个步骤，如果缓存中有对应的域名，就无需进行 DNS 解析，直接返回该域名对应的 IP 地址。</p><h4 id="协议栈：分层管理"><a href="#协议栈：分层管理" class="headerlink" title="协议栈：分层管理"></a>协议栈：分层管理</h4><p>得到了目标服务器的 IP 地址后，就可以把 HTTP 的传输工作交给操作系统的<strong>协议栈</strong>。协议栈分为好几个部分，分别承担自己的工作，上面的部分会向下面委托工作，下面的部分收到委托的工作并执行。</p><p>浏览器通过调用<code>Socket</code>库，来委托协议栈工作。其中上半部分为负责收发数据的<code>TCP</code>与<code>UDP</code>协议，受到应用层的委托执行收发数据的操作；下半部分用<code>IP</code>协议控制网络包收发操作，在互联网上传数据时，切分成数据包，而将网络包发送给对方的操作就是由<code>IP</code>负责的。</p><p>其中<code>IP</code>还包括其他协议：</p><ul><li><code>ICMP</code>用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><code>ARP</code>用于根据 IP 地址查询对应的以太网 MAC 地址。</li></ul><blockquote><p>Notice：虽然<code>ARP</code>协议需要使用 IP 地址进行工作，但是其仍然为数据链路层的协议，这是因为<code>ARP</code>的主要功能是处理局域网内的地址解析，直接影响数据链路层的操作。( 计算机考研 408 中 ARP 是网络层的协议)</p></blockquote><p>IP 下面的网卡驱动负责控制网卡硬件，网卡负责完成实际的数据收发操作。</p><h4 id="TCP-：可靠传输"><a href="#TCP-：可靠传输" class="headerlink" title="TCP ：可靠传输"></a>TCP ：可靠传输</h4><p><code>HTTP</code>是基于<code>TCP</code>的协议传输的，首先根据<code>TCP</code>的报文头部查看需要哪些字段信息。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures/img/5d0c331c5378f22175.jpg" alt="图5 TCP 报文头部格式" width="500"/><ul><li><strong>源端口</strong>和<strong>目的端口</strong>：用来标识发送给主机上哪个应用程序的。</li><li><strong>序号</strong>：为了解决包乱序的问题，给数据标号。</li><li><strong>确认号</strong>：目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，用于解决发送过程中出现的丢包问题。</li><li><strong>状态位</strong>：<code>TCP</code>是面向连接的服务，因此双方需要维护连接状态，因此标识就起到了很重要的作用，如<code>SYN</code>标识发起一个请求，<code>ACK</code>是回复，<code>RST</code>是重新连接，<code>FIN</code>是结束连接……</li><li><strong>窗口大小</strong>：<code>TCP</code>要实现<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够处理能力。</li></ul><p>除了流量控制，<code>TCP</code>还会用<strong>拥塞控制</strong>，控制发送速度。</p><p><code>TCP</code>传输数据之前，还要进行三次握手建立连接。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures/img/35-handshake.png" alt="图6 三次握手" width="500"/><p>三次握手的流程如下：</p><ol><li>客户端和服务端都处于<code>CLOSED</code>状态，先是服务器主动监听某个端口，处于<code>LISTEN</code>状态。</li><li>客户端主动发起连接<code>SYN</code>，之后处于<code>SYN-SENT</code>状态。</li><li>服务器接收到连接请求，返回<code>SYN</code>，并且<code>ACK</code>客户端的<code>SYN</code>，之后处于<code>SYN-RCVD</code>状态。</li><li>客户端收到服务端发送的<code>SYN</code>和<code>ACK</code>之后，发送对<code>SYN</code>确认的<code>ACK</code>，之后处于<code>ESTABLISHED</code>状态。因为完成一发收。</li><li>服务端收到<code>ACK</code>之后，处于<code>ESTABLISHED</code>状态，因为完成一发收。</li></ol><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><h4 id="IP-远程定位"><a href="#IP-远程定位" class="headerlink" title="IP : 远程定位"></a>IP : 远程定位</h4><p><code>TCP</code>需要委托<code>IP</code>将数据封装成数据包发送给通信对象。<code>IP</code>的头部组成部分如下所示。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures/img/5d0c3dedd0fa910049.jpg" alt="图7 IP  报文格式" width="500"/><ul><li><strong>源地址</strong>和<strong>目标地址</strong>：前者即客户端的输入的 IP 地址；后者即目标主机的 IP 地址。</li><li><strong>协议号</strong>：由于<code>HTTP</code>是使用<code>TCP</code>传输的，因此数据包头部需要填写<code>0x06</code>，标识协议为<code>TCP</code>。</li></ul><h4 id="MAC-：两点传输"><a href="#MAC-：两点传输" class="headerlink" title="MAC ：两点传输"></a>MAC ：两点传输</h4><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。MAC 头部是以太网的头部，它包含了接收方和发送方的 MAC 地址等信息。</p><p>在 MAC 包头里需要<strong>发送方MAC地址</strong>和<strong>接收方MAC地址</strong>，用于两点传输。一般在 TCP&#x2F;IP 通信中，MAC 包头的协议类型只使用：</p><ul><li>IP 协议：0x0800</li><li>ARP 协议：0x0806</li></ul><p>此时的数据已经被封装成如下形式：</p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg" alt="图8 数据链路层的报文" width="500"/><blockquote><p>那么如何获取接收方的 MAC 地址呢？</p></blockquote><p>此时就会用到 ARP 协议，ARP 协议会在以太网中以广播的形式发送”Who has ··· IP ? Tell me ··· IP”  ，对以太网所有的设备发送 ARP 请求。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures/img/20240825195508.png" alt="图9 Wireshark 抓包ARP 协议" width="700"/><p>如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p><p>当然，并不是每次转发网络包都要使用 ARP 协议，只要查询过一次<code>&lt;IP, MAC&gt;</code>就会将其存放到 ARP 缓存中去方便之后使用，只不过缓存的时间就几分钟。</p><p>也就是说，网络包实际的请求过程为：</p><ol><li>先查询 ARP 缓存，如果其中保存了对方的 MAC 地址，那么就不需要使用 ARP 查询，直接拿来使用。</li><li>否则，就使用 ARP 请求广播去请求对方的 MAC 地址。</li></ol><h4 id="网卡：发送出口"><a href="#网卡：发送出口" class="headerlink" title="网卡：发送出口"></a>网卡：发送出口</h4><p>网络包只是存放在内存中的一串二进制编码。因此，想要发送这些信息，需要将<strong>数字信号转换为电信号</strong>，才能在网线上传输，这才是真正的数据发送过程。</p><p>负责这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列（FCS）</strong>。</p><ul><li>起始帧分界符：标识包起始位置的标记</li><li>FCS：用于差错检验</li></ul><h4 id="交换机：送别者"><a href="#交换机：送别者" class="headerlink" title="交换机：送别者"></a>交换机：送别者</h4><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。其工作在 MAC 层。其工作过程如下：</p><ol><li>电信号到达网线接口，交换机里的模块进行接收，将电信号转换为数字信号。</li><li>通过末尾的 FCS 校验差错，如果没有问题则放到缓冲区。</li><li>存入缓冲区之后，查询这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录。交换机的 MAC 地址表主要包含两个信息：<ul><li>设备的 MAC 地址</li><li>该设备连接在交换机的哪一个端口上</li></ul></li><li>如果查询到了对应的 MAC 地址，则发送到对应的端口上；否则，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</li></ol><p>此外，如果接收到的 MAC 地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。</p><ul><li>MAC 地址中的广播：<code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的广播：<code>255.255.255.255</code></li></ul><h4 id="路由器：处境大门"><a href="#路由器：处境大门" class="headerlink" title="路由器：处境大门"></a>路由器：处境大门</h4><p>路由器的转发工作原理和交换机类似，也是通过查表判断包转发的目标。但在具体的操作过程，两者有些区别：</p><ul><li>路由器基于 IP 设计：俗称三层网络设备，其各个端口都具有 MAC 地址和 IP 地址。</li><li>交换机基于 MAC 设计：俗称二层网络设备，其端口不具有 MAC 地址。</li></ul><p>以下分解路由器转发包的过程：</p><ol><li>首先路由器端口会接收发给自己的以太网包，首先将其转化为数字信号，通过包末尾的 FCS 进行错误校验，如果校验不通过则丢弃该包。</li><li>接着<strong>检查 MAC 地址的接受方是否为自己</strong>，如果不是路由器端口的 MAC 地址，则丢弃；否则将数据包放入缓冲区中。</li><li>完成包接收工作后，路由器就会去掉包开头的 MAC 头部。MAC 头部的作用就是将包送达路由器，因此其任务已经完成。接着路由器会根据 MAC 头部后方的 IP 头部中的内容进行包转发，转发通过<strong>查询路由表</strong>判断下一步转发的目标。</li></ol><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg" alt="图10 路由表" width="500"/><ol start="4"><li>根据匹配得到的路由条目判断对方的地址，一共有两种情况：<ul><li>如果网关是一个 IP 地址，则这个 IP 地址就是要转发到的目标地址，还未到达目标网络，需要继续路由转发。</li><li>如果网关未空，则 IP 头部的接收方 IP 地址就是要转发的目标地址，也是找到了目标网络。</li></ul></li><li>由于之前丢弃了 MAC 头部，因此还需要通过 ARP 协议根据 IP 地址查询目标的 MAC 地址，将查询的结果作为接收方的 MAC 地址。通过 ARP 协议或者缓存中获取到了目标的 MAC 地址，那么需要源 MAC 地址，这个地址就是发送端口的 MAC 地址，再加以太类型字段，填写<code>0x0800</code>表示 IP 协议。</li><li>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。</li><li>如果已经在目标网络，那么通过交换机转发就能到达目的地；否则，还需要通过路由器转发，直到到达目标网络，最后到达目的地。</li></ol><h4 id="服务器与客户端：一个装一个拆"><a href="#服务器与客户端：一个装一个拆" class="headerlink" title="服务器与客户端：一个装一个拆"></a>服务器与客户端：一个装一个拆</h4><p>数据包送达到了服务器端口后，会经历如下几个步骤：</p><ol><li>首先查看数据包的 MAC 头部，是否和服务器自己的 MAC 地址匹配。</li><li>接着查看数据包的 IP 头，查看 IP 地址是否符合，并且根据 IP 头中的协议项，知道上一层是 TCP 协议。</li><li>接着查看数据包的 TCP 头，查看序列号，看看序列号是不是想要的，如果是就放入缓存中然后返回一个 ACK，否则就将该包丢弃。TCP 头部里还有端口号，此时 HTTP服务器正监听该端口。</li><li>服务器接着将该包发送给 HTTP 进程。</li><li>HTTP 进程发现该包要请求网页，于是将这个网页封装在 HTTP 响应报文里。</li><li>HTTP 响应报文加上 TCP、IP、MAC 头部，只是其源地址为服务器 IP 地址，目标地址是客户端 IP 地址。然后从网卡中发送出去。</li><li>客户端手打送响应数据包后，同样的方式进行拆包，得到 HTTP 响应报文，交给浏览器去渲染页面。</li><li>最后，客户端向服务器发起 TCP 四次挥手，至此双方的连接就断开了。</li></ol><h2 id="3-传输层"><a href="#3-传输层" class="headerlink" title="3. 传输层"></a>3. 传输层</h2><h3 id="3-1-传输层总览"><a href="#3-1-传输层总览" class="headerlink" title="3.1 传输层总览"></a>3.1 传输层总览</h3><div class="markmap-container" style="height:300px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;传输层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;提供服务：进程之间的逻辑通信、复用和分用、差错检验、面向连接的TCP和无连接的UDP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;UDP协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;特点：无连接、多对多、首部开销小、最大努力交付，应用层要保证可靠性&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;首部：8B，分别为源端口号、目的端口号、长度、校验和&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;TCP协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;特点：有连接、一对一、提供可靠交付、全双工通信、面向字节流&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;首部：20B，源端口，目的端口、序号、确认号、标志、窗口等&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;连接管理：三次握手建立，四次挥手释放&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;可靠传输&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;序号：用来保证数据能有序提交给应用层&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;确认：确认号为期待收到的下一个报文段第一个字节的序号&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;重传&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;超时：计时器到期未收到&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;冗余确认：当收到失序报文时向发送端发送冗余ACK&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;流量控制：在确认报文中设置接收串口rwnd的值来限制发送速率&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;拥塞控制：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;原理：根据自己估算网络拥塞成都设置cwnd的值来限制发送速率&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;方法：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;慢开始：当cwnd&amp;lt;ssthresh时，&lt;strong&gt;每收到一个报文段&lt;/strong&gt;cwnd ++&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;拥塞避免：当cwnd&amp;gt;ssthresh时，&lt;strong&gt;每经过一个往返延时&lt;/strong&gt;cwnd ++&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;快重传：当收到连续三个重复 ACK，直接重传对方期待的报文。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;快恢复：当收到连续的三个冗余 ACK。令 cwnd=cwnd/2, ssthresh=cwnd。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;拥塞实力：令 ssthresh=cwnd/2, cwnd设置为初始值&quot;}]}]}]}"></svg></div><h3 id="3-2-传输层的功能"><a href="#3-2-传输层的功能" class="headerlink" title="3.2 传输层的功能"></a>3.2 传输层的功能</h3><ol><li>传输层提供应用进程之间的逻辑通信，即<strong>端到端的通信</strong>。与网络层的区别是，网络层提供的是<strong>主机之间的逻辑通信</strong>。从网络层来说，通信的双方是两台主机，IP 数据报的首部给出了这两台主机的 IP 地址。但两台主机实际上是两台主机中的应用进程之间的通信。</li><li>复用和分用。复用是指发送方不同的应用进程都可以使用同一个传输层协议传送数据；分用是指接收方的传输层在剥去报文首部后能够把数据正确交付到目标应用程序。</li><li>传输层会对收到的报文进行差错检验。而网络层只检查 IP 数据包的首部，不检查数据部分是否出错。</li><li>提供两种不同的传输协议，即面向连接的 TCP 和无连接的 UDP。</li></ol><h3 id="3-3-TCP-协议"><a href="#3-3-TCP-协议" class="headerlink" title="3.3 TCP 协议"></a>3.3 TCP 协议</h3><h4 id="TCP-头部有哪些字段？"><a href="#TCP-头部有哪些字段？" class="headerlink" title="TCP 头部有哪些字段？"></a>TCP 头部有哪些字段？</h4><ul><li>序列号：建立连接时生成的随机数作为其初始值，通过 SYN 包传给接收主机，每发送一次数据就累加一次数据字节数的大小。用来解决网络包乱序问题。</li><li>确认应答号：表示下一次期望收到的数据的序列号，发送端收到这个确认应答以后认为在这个序号以前的数据都已经被正常接收。用来处理丢包问题。</li><li>控制位标志：<ul><li>ACK ：置<code>1</code>时，表示确认应答字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外都必须置为<code>1</code>。</li><li>RST ：置<code>1</code>时，表示 TCP 连接出现异常必须强制断开连接。</li><li>SYN ：置<code>1</code>时，表示希望建立连接，并在其序列号字段进行序列号初始值设置。</li><li>FIN : 置<code>1</code>时，表示之后不会再有数据发送，希望断开连接。断开连接时，双方互相交换 FIN 为<code>1</code>的 TCP 段。</li></ul></li></ul><h4 id="为何要使用-TCP-协议"><a href="#为何要使用-TCP-协议" class="headerlink" title="为何要使用 TCP 协议"></a>为何要使用 TCP 协议</h4><p><code>IP</code>层是不可靠的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。因此就需要上层的<code>TCP</code>协议去负责可靠性。确保接收到的网络包是<strong>无损坏、无间隔、非冗余和按序</strong>的。</p><h4 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h4><p>建立一个 TCP 连接是需要客户端与服务端达成三个信息的共识：</p><ul><li>Socket ： 由 IP 地址和端口号组成</li><li>序列号：用来解决乱序问题等</li><li>窗口大小：用来做流量控制</li></ul><h4 id="TCP-三次握手过程"><a href="#TCP-三次握手过程" class="headerlink" title="TCP 三次握手过程"></a>TCP 三次握手过程</h4><p>TCP 是面向连接的协议，所以使用 TCP 前必须建立连接，而建立连接是通过三次握手来进行的。三次握手的过程如下所示：</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures/img/35-handshake.png" alt="图11 三次握手" width="500"/><ol><li>客户端随机初始化序号（client_isn），将序号放到 TCP 首部的序号字段中，同时把 SYN 标志位设置为<code>1</code>，表示该报文是 SYN 报文。接着发送该报文给服务端。</li><li>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的序号字段中，其次把 TCP 首部的确认应答号字段填入<code>client_isn + 1</code>，接着 SYN 和 ACK 标志位设置为 1。最后把该报文发送给客户端，该报文也不包含应用层数据。</li><li>客户端收到服务端报文后，返回最后一个应答报文给客户端，首先该应答报文 TCP 首部 ACK 标志位置为<code>1</code>，其次确认应答号填入<code>server_isn + 1</code>，最后发送报文给服务端，这次报文可以携带客户到服务端的数据。</li></ol><h4 id="为何-TCP-连接时三次握手？"><a href="#为何-TCP-连接时三次握手？" class="headerlink" title="为何 TCP 连接时三次握手？"></a>为何 TCP 连接时三次握手？</h4><p>之所以需要三次握手原因是：</p><ul><li>三次握手才可以阻止重复历史连接的初始化<ul><li>两次握手的情况下，服务器没有中间状态给客户端来阻止历史连接，导致服务器可能建立一个历史连接，造成资源浪费。为了解决这个问题，就需要在服务器发送数据前，阻止历史连接，所以需要三次握手。</li></ul></li><li>三次握手才可以同步双方的初始序号<ul><li>两次握手只能保证一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被正确收到。</li></ul></li><li>三次握手才可以避免资源浪费</li></ul><p>不使用两次握手和四次握手的原因：</p><ul><li>两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步序列号。</li><li>四次握手：三次握手足够实现连接信息同步，因此没必要使用四次握手。</li></ul><h4 id="为什么需要随机初始化序列号？"><a href="#为什么需要随机初始化序列号？" class="headerlink" title="为什么需要随机初始化序列号？"></a>为什么需要随机初始化序列号？</h4><p>随机初始化序列号的原因是：</p><ul><li>为了防止历史报文被下一个相同的四元组的连接接收</li><li>为了安全性，防止黑客伪造相同序列号的 TCP 报文被对方接收</li></ul><h4 id="IP-层能分片，那MSS什么用？"><a href="#IP-层能分片，那MSS什么用？" class="headerlink" title="IP 层能分片，那MSS什么用？"></a>IP 层能分片，那MSS什么用？</h4><ul><li>MTU ：一个网络包的最大长度，以太网中为 1500 字节</li><li>MSS ： 去除 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li></ul><p>看似 MSS 的设置没有必要，实则十分重要。这是因为在 IP 层并没有超时重传机制，如果一个 IP 分片丢失，那么整个 IP 报文的所有分片都要重传，如果这个 IP 报文设置的过长，那么会降低重传的效率。所以，在建立连接的时候，通信双方需要协商 MSS 值，如果超过 MSS 就需要对数据进行分片，分完片的数据包不会超过 MTU 所设置的长度，自然也不会在 IP 层进行分片，因此大大增加重传的效率。</p><h4 id="TCP-四次挥手过程"><a href="#TCP-四次挥手过程" class="headerlink" title="TCP 四次挥手过程"></a>TCP 四次挥手过程</h4><p>TCP 四次握手双方都可以主动断开连接，断开连接后主机中的资源将被释放，过程如下：</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures/img/76ca70b09950ea27e18101a84a53f5ccdb60e2.png" width="400" alt="图12 TCP 四次挥手"/><ol><li>客户端打算关闭连接，因此发送一个 TCP 首部 FIN 标志置 1 的报文给服务端。</li><li>服务端收到该报文后，就向客户端发送 ACK 应答报文。</li><li>等待服务端将数据处理完后，也向客户端发送 FIN 报文。</li><li>客户端收到服务端的 FIN 报文后，回应一个 ACK 应答报文。</li><li>服务端收到 ACK 后关闭连接。</li><li>客户端经过<code>2MSL</code>时间后，也关闭连接。</li></ol><blockquote><p>Notice : 主动关闭连接的一方，才有 TIME_WAIT 状态</p></blockquote><h4 id="为什么要设置-TIME-WAIT-状态"><a href="#为什么要设置-TIME-WAIT-状态" class="headerlink" title="为什么要设置 TIME_WAIT 状态"></a>为什么要设置 TIME_WAIT 状态</h4><ul><li>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收<ul><li>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</li></ul></li><li>保证被动关闭连接的一方，能被正确的关闭<ul><li>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</li></ul></li></ul><h4 id="序列号和确认号如何变化"><a href="#序列号和确认号如何变化" class="headerlink" title="序列号和确认号如何变化"></a>序列号和确认号如何变化</h4><p>发送 TCP 报文的规律可以总结如下：</p><ul><li>公式一：$\text{序列号}&#x3D;\text{上次发送的序列号} + len(数据长度)$。特殊情况，如果上一次发送的 SYN 报文或是 FIN 报文，则改为 $\text{上次发送的序列号}+1$。</li><li>公式二：$确认号 &#x3D; 上一次收到的报文中的序列号 + len(数据长度)$。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为 $\text{上一次收到的报文中的序列号} + 1$。</li></ul><h3 id="3-4-UDP协议"><a href="#3-4-UDP协议" class="headerlink" title="3.4 UDP协议"></a>3.4 UDP协议</h3><h3 id="3-5-TCP协议与UDP协议区别"><a href="#3-5-TCP协议与UDP协议区别" class="headerlink" title="3.5 TCP协议与UDP协议区别"></a>3.5 TCP协议与UDP协议区别</h3><ol><li>连接</li></ol><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><ol start="2"><li>服务对象</li></ol><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一，一对多，多对多的交互通信。</li></ul><ol start="3"><li>可靠性</li></ol><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢弃、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul><ol start="4"><li>拥塞控制、流量控制</li></ol><ul><li>TCP 有拥塞控制和流量控制，保证数据传输的安全性。</li><li>UDP 则没有。</li></ul><ol start="5"><li>首部开销</li></ol><ul><li>TCP 首部长度较长，在没有选项字段的是 20 个字节。</li><li>UDP 首部只有 8 个字节，并且固定不变的，开销较小。</li></ul><ol start="6"><li>传输方式</li></ol><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包传输的，有边界，可能会丢包和乱序。</li></ul><ol start="7"><li>分片不同</li></ol><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，到达主机后在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要重传这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着传给传输层。</li></ul><h2 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h2><h3 id="4-1-网络层总览"><a href="#4-1-网络层总览" class="headerlink" title="4.1 网络层总览"></a>4.1 网络层总览</h3><div class="markmap-container" style="height:450px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;网络层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;功能：异构网络互联、路由与转发、拥塞控制&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;路由算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;静态：由网络管理员手动配置路由信息&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;动态：通过路由器间彼此交换的信息来构造路由表，分为&lt;code&gt;距离-向量&lt;/code&gt;和&lt;code&gt;链路状态&lt;/code&gt;算法。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;层次路由&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;概念：将互联网分成许多较小的自治系统，系统有权决定内部采用什么路由协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;内部网关协议：RIP、OSPF&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;外部网关协议：BGP4&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;IPv4&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;首部：固定部分共20B。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;NAT：专门实现专用网络地址和公用网络地址的互相转换 (实际工作在运输层)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;CIDR：在变长子网掩码的基础上提出的一种消除传统A、B、C类网络划分&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;路由聚合&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;概念：将网络前缀都相同的连续的IP地址组成CIDR地址块&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;目的：使得一个地址块可以表示很多地址，减少路由表表项和路由器间的信息交换&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;方法：把一串IP地址都写成二进制，取最长的公共前缀作为网络号&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;ARP：对于特定的IP地址，查询其对应的物理地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;DHCP：给网络中的主机动态的分配IP地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;ICMP：用来给主机或路由器报告差错和异常情况&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;IPv6：首部40B，地址长度16B，主要用于解决IPv4用尽问题&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;路由协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;IGP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;RIP协议：基于距离向量路由选择协议，使用UDP，与相邻路由器交换整个路由表&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;OSPF协议：基于链路状态路由算法，使用IP，与全部路由器交换相邻结点链路状态&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;EGP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;BGP协议：基于路径向量路由选择协议，使用TCP，寻找的并非最佳路由&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;移动IP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;概念：移动结点以固定的网络IP地址，实现跨越不同网段的漫游功能&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;组成：移动结点、本地代理、外部代理&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;路由器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;特点：可以用来连接异构网络，完成路由转发，能隔离冲突域和广播域，依照IP地址转发&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;组成&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;控制部分：路由选择处理机，根据路由协议构造与维护路由表&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;分组转发部分：交换结构、一组输入端口和一组输出端口&quot;}]}]}]}]}"></svg></div><h3 id="4-2-路由器"><a href="#4-2-路由器" class="headerlink" title="4.2 路由器"></a>4.2 路由器</h3><p>路由器主要完成两个功能：一个是路由选择（确定哪一条路径），另一个就是分组转发（当一个分组到达时采取的动作）。前者根据路由选择协议构造出路由表，同时经常或定时地和相邻路由器交换路由信息而不断地更新和维护路由表；后者处理通过路由器的数据流，关键操作是转发表查询、转发及相关的队列管理和任务调度。</p><h3 id="4-3-路由算法"><a href="#4-3-路由算法" class="headerlink" title="4.3 路由算法"></a>4.3 路由算法</h3><h4 id="RIP-距离-向量路由算法"><a href="#RIP-距离-向量路由算法" class="headerlink" title="RIP 距离-向量路由算法"></a>RIP 距离-向量路由算法</h4><p>路由信息协议（Routing Information Protocol，RIP ）是自治系统内部一个可以使用的路由选择协议，是基于距离向量的路由选择协议，其最大有点就是简单，其规定：</p><ol><li>网络中的每个路由器都要维护从它自身到其每个目的网络的距离记录。</li><li>距离也称为跳数，规定从一个路由器到直接连接网络的距离为 1，而经过一个路由器，距离加1。</li><li>RIP 认为好的路由就是通过的路由器的数量少，即优先选择跳数少的路径。</li><li>RIP 允许一条路径最多只能包含 15 个路由器。距离为 16 时则表示网络不可达。因此 RIP 只适用于小型互联网。最高跳数的目的时为了防止数据包不断循环在环路上，减少网络拥塞的可能性。</li><li>RIP 默认在任意两个使用 RIP 的路由器之间每 30s 广播一次 RIP 更新信息，从而实现动态维护。</li></ol><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures/img/20240826175017.png" alt="图13 RIP 更新方式" width="550"/><h4 id="OSPF-链路状态路由算法"><a href="#OSPF-链路状态路由算法" class="headerlink" title="OSPF 链路状态路由算法"></a>OSPF 链路状态路由算法</h4><p>开放最短路径优先（OSPF ）协议是使用分布式链路状态由算法的典型代表，也是内部网关协议的一种。与 RIP 相比有以下区别：</p><ol><li>OSPF 向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法。而 RIP 仅向自己相邻的几个路由器发送信息。</li><li>发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。“  链路状态  ”说明本路由器和哪些路由器相邻及该链路的代价。而在 RIP 中，发送的信息是本路由器所知道的全部信息，即整个路由表。</li><li>只有当链路状态发生变化时，路由器才用泛洪法向所有路由器发送此信息，而且更新过程收敛的快，不会出现 RIP “  坏消息传得慢”  的问题。RIP 中，不管网络拓扑是否发生变化，路由器之间都会定期交换路由表的信息。</li></ol><p>除此以外，OSPF 还有其他特点：</p><ol><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。被称为负载平衡。</li><li>OSPF 路由器之间交换的分组都具有鉴别能力，因而保证了仅在可依赖的路由器之间交换链路状态信息。</li><li>OSPF 对不同的链路可根据 IP 分组的不同服务类型设置不同的代价。因此，其更加灵活。</li></ol><h4 id="BGP-边界网关协议"><a href="#BGP-边界网关协议" class="headerlink" title="BGP 边界网关协议"></a>BGP 边界网关协议</h4><p>之所以要使用 BGP 是因为：</p><ol><li>因特网的规模太大，使得自治系统之间路由选择非常困难。</li><li>对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。</li><li>自治系统之间的路由选择必须考虑有关策略。</li></ol><h3 id="4-4-IP-层相关协议"><a href="#4-4-IP-层相关协议" class="headerlink" title="4.4 IP 层相关协议"></a>4.4 IP 层相关协议</h3><h4 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP 地址解析协议"></a>ARP 地址解析协议</h4><p>由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 ARP 协议，求得下一跳的 MAC 地址。ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的。具体的请求过程如下：</p><ol><li>主机会<strong>广播发送 ARP 请求</strong>，这个包包含了想要知道的 MAC 地址的主机的 IP 地址。</li><li>如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己 MAC 地址放入 ARP 响应包返回给主机。</li></ol><h4 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP 动态主机配置协议"></a>DHCP 动态主机配置协议</h4><p>电脑通常都是通过 DHCP 动态获取 IP 地址，大大省去了配 IP 信息繁琐的过程。其主要通过如下几个步骤获取 IP 地址：</p><ol><li>客户端首先发起<strong>DHCP发现报文（DHCP DISCOVER ）</strong>的数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，因此使用 UDP 进行广播发送，广播目的地址为 255.255.255.255（端口67 ）并使用 0.0.0.0（端口68 ）作为源 IP 地址。</li><li>DHCP 服务器收到 DHCP 发现报文，用 <strong>DHCP 提供报文（DHCP OFFER ）</strong>向客户端做出响应。此时仍然使用 IP 广播地址。</li><li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送<strong>DHCP 请求报文（DHCP REQUEST ）</strong>进行响应，回显配置的参数。</li><li>最后，服务端用 DHCP ACK 后 ，交付完成，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。</li></ol><p>如果租约的 DHCP IP 地址过期后，客户端就会像服务器发送 DHCP 请求报文：</p><ul><li>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。</li><li>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就停止使用租约的 IP 地址。</li></ul><h4 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h4><p>网络地址转换 NAT，是为了缓解 IPv4 地址耗尽的问题。由于绝大多数的网络应用都是使用传输层协议 TCP 或 UDP 来传输数据的，因此，可以把<code>IP 地址 + 端口号</code>进行转换，实现私有网络地址与端口与公有网络地址与端口的转换。</p><p>但是使用 NAT&#x2F;NAPT 也有缺点，由于其都依赖自己的转换表，因此会有以下问题：</p><ul><li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有记录值。</li><li>转换表的生成与转换表操纵会产生额外的开销</li><li>如果 NAT 路由器重启，所有的 TCP 连接都要重置。</li></ul><p>解决如上问题又两种方法：</p><ul><li>改用 IPv6增大地址空间。</li><li>NAT 穿透技术，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目。换种说法，客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信，因此就不需要 NAT 设备进行转换。</li></ul><h4 id="ICMP-互联网控制报文协议"><a href="#ICMP-互联网控制报文协议" class="headerlink" title="ICMP 互联网控制报文协议"></a>ICMP 互联网控制报文协议</h4><p>ICMP（Internet Control Message Protocol ）的主要功能就是确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</p><p>ICMP 大致可以分为如下两类：</p><ul><li>诊断查询信息，即<strong>查询报文类型</strong><ul><li>类型 0 ：回送应答（Echo Reply）</li><li>类型 8 ：回送请求（Echo Request）</li></ul></li><li>通知出错原因的错误信息，即<strong>差错报文类型</strong><ul><li>类型 3 ：目标不可达（Destination Unreachable）</li><li>类型 4 ：原点抑制（Source Quench）</li><li>类型 5 ： 重定向或改变路由（Redirect）</li><li>类型 11 ：超时（Time Exceeded）</li></ul></li></ul><blockquote><p>ping 命令是如何执行的？</p></blockquote><ol><li>源主机首先会构造一个 ICMP 回送请求信息数据包，其中数据包中有两个重要的字段<ul><li>类型，即回送请求类型 8</li><li>序号，用于区分连续 ping 时发出的数据包、</li></ul></li><li>交付给 IP 层，加上 IP 层头部，构造成一个 IP 数据包。</li><li>主机 B 收到数据包后，构造一个 ICMP 回送响应消息数据包，其类型为 0 ，序号为请求数据包的序号。</li><li>在规定时间，源主机没有收到 ICMP 的应答包，则说明目标主机不可达；如果接收到了回送响应消息，则说明目标主机可达。</li></ol><h2 id="5-数据链路层"><a href="#5-数据链路层" class="headerlink" title="5. 数据链路层"></a>5. 数据链路层</h2><h3 id="5-1-数据链路层总览"><a href="#5-1-数据链路层总览" class="headerlink" title="5.1 数据链路层总览"></a>5.1 数据链路层总览</h3><div class="markmap-container" style="height:450px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;数据链路层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;功能：为网络层提供服务、链路管理、帧定界、帧同步与透明传输、流量控制和差错控制。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;组帧&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;字符计数法：在帧头部使用一个计数字段来标明帧内字符数&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;首尾定界法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;概念：使用特定字符或比特模式定帧的开始和结束&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;字符填充：在数据中的特殊字符前面使用转移字符填充&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;比特填充：数据区每遇到连续5个1就填充一个&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;差错控制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;检错编码：奇偶校验码、循环冗余码&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;纠错编码：海明码&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;可靠传输：使用确认和超时重传两种机制来保证可靠传输&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;流量控制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;停止等待协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;后退N帧协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;选择重传协议&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;设备&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;网桥&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;特点：把两个或多个以太网通过网桥连接变成一个网段&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;类型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;透明网桥：按照自学习算法填写转发表&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;源路由网桥：先发送发现帧，按返回结果转发&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;交换机&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;特点：实际就是一个多端口网桥&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;相同点：按MAC地址转发，都能隔离冲突域，不能隔离广播域&quot;}]}]}"></svg></div><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://www.xiaolincoding.com/network/">图解网络</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> CS Basics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Network </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to study</title>
      <link href="/posts/How-to-study.html"/>
      <url>/posts/How-to-study.html</url>
      
        <content type="html"><![CDATA[<h2 id="本文思维导图"><a href="#本文思维导图" class="headerlink" title="本文思维导图"></a>本文思维导图</h2><div class="markmap-container" style="height:250px">  <svg data="{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;How to study&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;学习的三个要点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;如何开始&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;学科范围&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;基础知识&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;十步学习法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;第1步到第6步：只做一次的步骤&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;第1步：了解全局&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;第2步：确定范围&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;第3步：定义目标&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;第4步：寻找资源&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;第5步：创建学习计划&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;第6步：筛选资源&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;第7步到第10步：循环往复&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;第7步：开始学习，浅尝辄止&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;第8步：动手操作，边玩边学&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;第9步：全面掌握，学以致用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;第10步：乐为人师，融会贯通&quot;}]}]}]}"></svg></div><blockquote><p>教育就是一个人把在学校所学全部忘光之后剩下的东西。 —— 阿尔伯特·爱因斯坦</p></blockquote><p>在当今这个瞬息万变的世界里，学习的能力和效率至关重要。如果科研工作者或软件开发者选择固步自封，忽视技能的提升，很快就会被时代抛在后面。因此，为了避免这种情况，必须掌握在信息爆炸的时代中高效学习的方法。本文旨在教你如何进行自学。</p><h2 id="1-学习的过程"><a href="#1-学习的过程" class="headerlink" title="1. 学习的过程"></a>1. 学习的过程</h2><blockquote><p>教育的首要目标，并在与 “  知” 而在于 “  行” —— 赫伯特 · 斯宾塞</p></blockquote><p>在学习过程中，人们常常会遇到如何更好地记住和理解知识的挑战。如果别人告诉你该怎么做，你会有很大的可能忘掉，但如果你自己动手做一次，你可能就记住了。更进一步，如果你能将自己所学的东西教给别人，你不仅能记住，还能理解得更深刻。尽管每个人的学习方式都会有所不同，但是通过动手实践或是教授他人，一定能让你学的更好。与其他学习相比，主动学习是效率更高的方式。</p><p>举例来说，许多软件开发人员在刚开始学习编程语言或是框架时，可能会选一本相关的书籍，从头到尾地先读上一遍，奢望自己能够完全吸收其中所有的知识点。使用这种方法，确实能够学习到东西，但是效率很低，而且还需要经常回顾书中的内容，来弥补学习该技术存在的知识短板。当然，如果在拥有足够的时间的前提下且没有具体的目标时，这种学习方法很好，无非就是花时间。但当有更紧迫的理由需要快速学习时，这种方法就无法奏效了。而且更重要的一点是书本中的知识可能适合作为参考资料，而不适合实际的去学习。</p><p>那么想要学习一些东西，你应该做什么？正如刚才所说的，最好的办法就是付诸实践，即使你还不知道自己在做什么。如果关于某个主题你能够获得足够的知识能够操作，你就可以发挥自己强大的创造力和好奇心。当能够在一件事情上尽情发挥的时候，你的内心就更倾向于吸收更多的信息，思考更有意义的问题。</p><p>一旦你已经实践过，自然而且你会遇到各式各样的问题，这时回到书本当中，你就会有强烈的冲动去消化吸收其中的内容。因为你已经积攒了很多想要找到答案的问题，你对哪些内容重要早已经了然于胸。然后，可以继续把自己学到的新知识重新应用于实践中，看看学到的新方法是否能解决你已有的问题。以解决实践过程中发现的问题为目标，向着这个方向重复这个循环，周而复始。</p><p>最后，你可以将自己学习到的内容教给别人。关键在于，你要用自己的语言将这些信息组织起来，把你的思想表述给别人。</p><p>OK，到目前为止，本文已经介绍完了学习背后的逻辑，但光有理论的支撑，没有实际的方法论是远远不够的。接下来，我们将深入探讨一些具体的学习策略和方法，帮助你将理论转化为可操作的步骤。</p><h2 id="2-学习的三个要点"><a href="#2-学习的三个要点" class="headerlink" title="2. 学习的三个要点"></a>2. 学习的三个要点</h2><p>在讲述方法论之前，首先明确学习的三个要点，前文中讲到拿一本书籍通读全文可能并不是一个好的学习方法，这不利于在短期内掌握一门技术并快速上手。因此，这也迫使我们去寻找更好的学习方式，能够在有限的时间内掌握到自己所需要的内容，再去寻找能获得这些信息的最佳资源，同时忽略那些并非达成目标所必须的其他信息。</p><p>明确了我们学习的目的，接下来就解决以下三个要点：</p><ul><li>如何开始 —— 要想开始使用自己所学的，需要掌握哪些基本知识？</li><li>学科范围 —— 现在学的东西有多宏大？应该怎么做？再开始阶段，不需要先了解每个细节，但如果能够该学科的轮廓有大致的了解，那么将来就能<strong>发现更多的细节</strong>。</li><li>基础知识 —— 不止在开始阶段，要想使用一项特定的技术，需要了解基本的用户案例和最常见的问题，也需要知道自己学的哪 20% 能够满足 80% 的日常应用。</li></ul><p>熟知以上三个关键点后，在无须通晓全部细节的情况下，也能高效地学习一门技术。了解了这三项主题 —— 如何开始，能做什么，以及相关的基础知识，那么就能随着学习深入学会所需的其他知识，如果是想提前掌握所有知识，那只是在浪费时间，这样只会让真正有用的内容湮灭在那些细枝末节之中。这一点你可以回想你有多少次从头到尾仔细阅读一本技术书籍，却发现自己实际用到的也只是书里介绍的技术的一小部分，而且如果你没有实践，没有思考，那么大部分的内容你都会遗忘。</p><p>介绍完学习的三个要点，接着就可以介绍自学的方法论 —— <strong>十步学习法</strong>。</p><h2 id="3-十步学习法"><a href="#3-十步学习法" class="headerlink" title="3. 十步学习法"></a>3. 十步学习法</h2><p>十步学习法的基本思想就是：要对自己要学的内容有个基本的了解——了解自己不知道什么就足矣。然后，利用这些信息够了出学习的范围，即下阶段应该学习什么内容，以及学成之后又会获得什么。依靠这些知识，可以找出各种资源来帮助自己学习。最后，可以创建自己的学习计划，列出要去学习哪些相关课程，筛选学习资料，只保留能帮助自己达成目标的优质内容。</p><img src="https://cdn.jsdelivr.net/gh/TiredAce/pictures/img/20240823165049.png" alt="图1  十步学习法" width="300"/><p>十步学习法的第1 步到6 步是研究的步骤，它是一次性完成的。但是从第7 步到第10 步则是重复的过程，贯穿于学习的各个模块。这个方法十分的有效，因为它迫使你提前明确自己学习的目标，通过“  聚焦学习范围，关注重点内容”  来细化各个学习要点。当然每个人的学习习惯与方式也是不同的，完全可以根据自身的情况对该方法进行裁剪，保留你认为对你来说有用的部分。最终，找到适合自己的自学方法，而你的未来将仰仗于它。</p><p>接下来，本文将详细阐述这些步骤你需要做哪些事情。</p><h2 id="4-第1-步到第6-步：只做一次的步骤"><a href="#4-第1-步到第6-步：只做一次的步骤" class="headerlink" title="4. 第1 步到第6 步：只做一次的步骤"></a>4. 第1 步到第6 步：只做一次的步骤</h2><p>对于十步学习法的前六个步骤，你需要集中精力完成足够多的前期调研，确保自己知道要学哪些内容，以及如何确认自己已达成这些目标。你还将学到如何挑选最好的资源来帮自己实现目标、制订学习计划。</p><h3 id="第1-步：了解全局"><a href="#第1-步：了解全局" class="headerlink" title="第1 步：了解全局"></a>第1 步：了解全局</h3><p>在深入探究某个主题之前至少要对其有所了解，这一点非常重要。这样你才能弄清自己到底要学什么，找出最好的学习方式。所以在这一步你要做的就是了解自己将要学习的主题的全局。</p><p>要完成这一步，你需要对自己想要学的课题做一些基础性研究。通常你可以使用网络搜索来完成大部分研究。如果碰到相关主题的书籍，只需要阅读介绍性的章节，粗略浏览一下内容，但不要在这一步上花费太多时间。这一步的目的不是要掌握该主题，只是对这一主题的相关内容有一个全局性的了解。</p><h3 id="第2-步：确定范围"><a href="#第2-步：确定范围" class="headerlink" title="第2 步：确定范围"></a>第2 步：确定范围</h3><p>完成了第一步，你至少对自己的学习主题及其全局有了一个大致的了解。下一步就是集中精力去明确自己到底要学什么。在任何的项目中，明确项目的范围都是至关重要的，唯有这样才能了解项目的全局，做好相应的工作。</p><p>在学习过程中，大家很容易犯的一个错误就是试图解决太大的问题而把自己搞得不堪重负。因此，你要明确自己的学习范围。为此，你需要运用自己在上一步中获得的信息，让自己的关注点落脚到更小也更可控的范围。例如你可以确定如下学习主题：</p><ul><li><p>学习 C# ：学习 C# 语言的基础知识，掌握如何创建一个简单的控制台程序。</p></li><li><p>学习 Linux ：了解如何设置和安装 Ubuntu Linux ，以及如何使用它的基本特性。</p></li></ul><p>这样你就看到类似学习 C# 这个宏大的主题被你聚焦到一个特定的范围内中，从一个几乎无边界的主题中明确了一个清晰且聚焦的范围。</p><p>在这一步中，你可以充分利用自己在第1步中收集到的信息，找出自己的学习范围。同时也可以借助自己的学习理由来决定学习的范围。<strong>当然在此过程中，你可能会受到诱惑，为了学习该主题下的不同子主题，你可能会扩张你的学习范围而不够聚焦，但是请务必抵制住这个诱惑，尽可能地保持专注。</strong></p><h3 id="第3-步：定义目标"><a href="#第3-步：定义目标" class="headerlink" title="第3 步：定义目标"></a>第3 步：定义目标</h3><p><strong>在全力以赴启动之前，明确“  成功”  的含义极为重要</strong>。如果不知道成果是什么样子，很难找准目标，也很难知道自己什么时候已经真正达到目标。所以在尝试学习任何东西之前，你都应该能描绘出成功的样子。当你知道自己的目标是什么的时候，你就可以更轻松地使用倒推的方式，明确实现目标所需的步骤。</p><p><strong>好的成功标准应该是具体的、无二义性的。</strong>不要对自己想要完成的任务进行含糊不清的描述。相反，要列出某一特定的结果，或者一旦实现自己所能达到的目标你应该能够做到的事情。</p><p><strong>不好的标准</strong>：</p><ul><li>学习了关于C#语言的基础知识。</li><li>我知道如何使用HTML去构建一个网页。</li></ul><p><strong>好的标准</strong>：</p><ul><li>我可以利用C#语言的主要功能写出一个小的应用程序。</li><li>我可以使用HTML5在网上为我自己创建一个主页，展示我的简历和我的代表性工作。</li></ul><h3 id="第4-步：寻找资源"><a href="#第4-步：寻找资源" class="headerlink" title="第4 步：寻找资源"></a>第4 步：寻找资源</h3><p>要尝试收集到多种多样的资源以帮助你学习，而不是只读一本关于这一主题的书。资源可以是多种多样的，不局限于书籍。事实上，如今，随着互联网的广泛应用，各种类型的内容随处可见，你几乎可以针对自己感兴趣的任何主题，找到大量的资源，<strong>如图书、博客文章、视频、专家、博客、源代码、示例项目、在线文档</strong>等等。</p><h3 id="第5-步：创建学习计划"><a href="#第5-步：创建学习计划" class="headerlink" title="第5 步：创建学习计划"></a>第5 步：创建学习计划</h3><p>在这一步，你需要创建自己的学习路径。把它看作自己写书时的大纲。事实上，当你大功告成的时候，你会发现自己的学习路径可能与一本书的目录非常相似。你基本上就是完成一系列的模块，直到最后达成目标。这并不意味着你只要复制一本书的目录就可以称其为自己的学习计划了。有的书的内容超出你的需求，有的书的结构很差劲儿。通览你收集到的全部资源，你就对自己需要哪些内容以及如何组合这些内容有更清晰的认识。</p><h3 id="第6-步：筛选资源"><a href="#第6-步：筛选资源" class="headerlink" title="第6 步：筛选资源"></a>第6 步：筛选资源</h3><p>现在，你知道自己要学什么以及以什么顺序学，那么是时候决定要使用哪些资源来完成自己的学习任务了。为了研究一个主题要读10 本书、50 篇博客文章，并不现实，并且即使你真的这么做了，其中也有很大一部分是重复的。因此很有必要对现有资源进行筛选，从中选出最能帮助你实现自己的目标的资源。在这一步中，把你在第4 步中收集的全部资源浏览一遍，找出哪些内容能够覆盖你的学习计划。</p><h2 id="5-第7-步到第10-步：循环往复"><a href="#5-第7-步到第10-步：循环往复" class="headerlink" title="5. 第7 步到第10 步：循环往复"></a>5. 第7 步到第10 步：循环往复</h2><p>现在开始最有趣的部分。接下来的四个步骤会在你的学习计划所定义的各个模块中循环往复。</p><h3 id="第7-步：开始学习，浅尝辄止"><a href="#第7-步：开始学习，浅尝辄止" class="headerlink" title="第7 步：开始学习，浅尝辄止"></a>第7 步：开始学习，浅尝辄止</h3><p>大多数人，包括我自己，在学习过程中通常会犯两类错误：第一类错误是在知之不多的情况下就盲目开始，即行动太快；第二类错误是在行动之前准备过多，即行动太晚。要想在这二者之间取得平衡，你掌握的知识要恰到好处，足以能让你开始学习，但又不会多到让你无力探索，这样你的学习效果最佳。你要专注于掌握自己所需的、能在下一步动手操作的最小量的知识，即为了尽快进入实践阶段。你可以浏览参考材料，或者每章的摘要，或者各种简介，这些信息足以让你对自己要做什么有基本的认识。</p><h3 id="第8-步：动手操作，边玩边学"><a href="#第8-步：动手操作，边玩边学" class="headerlink" title="第8 步：动手操作，边玩边学"></a>第8 步：动手操作，边玩边学</h3><p>起初，你会觉得这步似乎并不重要，不过还是让我们先来考量一下其他的方式——大多数人学习的方式。大多数人会试图通过读书或观看视频来掌握某个主题。他们会提前吸收很多信息，然后再付诸实践。这一方法的问题在于，在他们读书或看视频的时候，他们并不知道哪些内容是重点。他们只是因循他人设计好的学习路径。</p><p>你无须提前了解全部内容，你要做的首要的一件事情就是亲自操作和亲身体验。采用这种方法，你通过探索和实践进行学习。在操作的过程中，你的大脑自然地产生各种问题：它是如何工作的？如果我这么做，会发生什么？我该如何解决这个问题？这些问题引导着你走向真正重要的方向。</p><p>把那些暂时还没有答案的问题记录下来，你在下一步中会有机会找出这些问题的答案。</p><h3 id="第9-步：全面掌握，学以致用"><a href="#第9-步：全面掌握，学以致用" class="headerlink" title="第9 步：全面掌握，学以致用"></a>第9 步：全面掌握，学以致用</h3><p>你通过动手操作发现了一些尚未找到答案的问题。现在，是时候来回答这些问题了。在这一步中，你要利用先前收集到的所有资料，进行深入学习。为了有效利用自己选择的资料，为上一步产生的问题寻求答案，阅读文字、观看视频、与他人交流都是必要手段。这能让你沉浸在学习材料中，尽可能地汲取知识。</p><p>不要害怕回头再去操作，付出更多，因为这不仅能让你找到问题的答案，也能让你学到新东西。给自己足够多的时间去深入理解自己的主题，你可以阅读，可以实验，可以观察，也可以操作。</p><p>最后，千万不要忘了，你在第3步中定义的成功标准。试着把自己正在学习的内容与最终目标关联起来。你掌握的每个模块，都应该以某种方式推动你向着终极目标前进。</p><h3 id="第10-步：乐为人师，融会贯通"><a href="#第10-步：乐为人师，融会贯通" class="headerlink" title="第10 步：乐为人师，融会贯通"></a>第10 步：乐为人师，融会贯通</h3><p>如果你想深入地掌握一门学问，想对这门学问做到融会贯通，那么你必须要做到“好为人师”。除此之外别无他法。在现实中，你只需要超前别人一步，就可以成为他们的老师。在这一过程中，你要切实剖析并理解自己所学的知识，将其内化到自己的思想；同时，你也要用能够让他人理解的方式精心组织这些信息。</p><p>重点在于，你要花时间将自己学到的东西从大脑中提取出来，以别人能够理解的方式组织起来。在经历了整个这个过程之后你会发现，有很多你以为自己明白了的知识点，其实并没有摸透。于是你会将那些以前自己没太明白的东西联系起来，并且简化自己大脑中已有的信息，将它们浓缩并经常复习。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>学会自学能让你收货无比丰厚的回报。通过使用十步学习法可以将你的学习过程更为结构化，而不是漫无目的地一头扎进浩渺的知识海洋之中。这些步骤本身并不重要，这一学习过程背后的理念才是真正重要的。重点就是你要开发出一套适合自己的自学体系，一套你可以持续不断地加以运用而获得丰硕成果的方法体系。</p><h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ul><li><a href="https://book.douban.com/subject/36044253/">软技能：代码之外的生存指南（第二版）</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Book review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
